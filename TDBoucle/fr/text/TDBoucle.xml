<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="../../../_templates/java/latex.xsl"?>
<lesson xmlns="http://www.elml.ch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.elml.ch ../../../_config/validate.xsd" 
	label="TDBoucle" title="TD Boucles">
	
	<entry>
		<paragraph>
			Voyons ici comment incorporer des boucles, les structures répétitives, dans nos codes et comment les utiliser à bon escient.
    </paragraph>
	</entry>
	
	<!-- =========================================================== -->
	<unit label="Boucles" title="Les boucles">
	<!-- =========================================================== -->

    <entry>
      <paragraph>
        Si on veut faire effectuer un travail répétitif, il faut indiquer deux choses :
        <list listStyle="ordered">
          <item>Le travail à répéter</item>
          <item>La manière de continuer la répétition ou de l’arrêter.</item>
        </list>
		</paragraph>
    </entry>
    
		<learningObject title="tant que">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        Le « <formatted style="code">tant que</formatted> » est une structure 
        qui demande à l’exécutant de répéter une tâche (une ou
        plusieurs instructions) tant qu’une condition donnée est vraie.
      </paragraph>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
tant que condition faire
    séquence d’instructions à exécuter
fin tant que
      </paragraph>
      <paragraph>
        La <formatted style="bold">condition</formatted> est une expression délivrant un résultat 
        <formatted style="bold">booléen</formatted> (vrai ou faux).
      </paragraph>
      <paragraph>
        Il faut qu’il y ait dans la séquence d’instructions comprise entre <formatted style="code">tant que</formatted>
        et <formatted style="code">fin tant que</formatted> au moins <formatted style="bold">une instruction qui 
        modifie</formatted> une des composantes de <formatted style="bold">la condition</formatted>
        de telle manière qu’elle puisse <formatted style="bold">devenir fausse</formatted> à un moment donné. Dans le cas contraire,
        la condition reste <formatted style="bold">indéfiniment vrai</formatted>e et la boucle va tourner sans fin, c’est ce qu’on appelle
        une <formatted style="bold">boucle infinie</formatted>.
      </paragraph>
      <paragraph>
        Si la condition est fausse dès le début, la tâche n’est jamais exécutée.
      </paragraph>
      <paragraph>
        <multimedia src="../image/boucleTq.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph title="Afficher les nombres plus petits que 10">On affiche uniquement les nombres inférieurs (pas strictement) à 10 .</paragraph>
      <paragraph cssClass="code">
// Affiche les nombres de 1 à 10.
module compterJusque10 () // version avec tant que
    nb : entier
    nb ← 1 // c’est le premier nombre à afficher
    tant que nb ≤ 10 faire // c’est le premier nombre à afficher
      afficher nb  // on affiche la valeur de la variable nb
      nb ← nb + 1 // on passe au nombre suivant
    fin tant que
fin module
      </paragraph>
      <paragraph title="Somme de nombres"> Après chaque nombre, on demande à l’utilisateur s’il y a encore un nombre à additionner.</paragraph>
      <paragraph cssClass="code">
// Lit des valeurs entières et retourne la somme des valeurs lues.
module sommeNombres() → entier
    valeur : entier // un des termes de l’addition
    somme : entier // la somme
    somme ← 0
    lire valeur
    tant que valeur ≥ 0 faire
      somme ← somme + valeur
      lire valeur // remarquer l’endroit où on lit une valeur.
    fin tant que
retourner somme
fin module
      </paragraph>
    </look>
		</learningObject>


		<learningObject title="faire - jusqu’à ce que">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        Cette structure est très proche du « <formatted style="code">tant que</formatted> » à deux différences près :
        <list listStyle="ordered">
          <item>
            Le <formatted style="bold">test</formatted> est fait <formatted style="bold">à la fin</formatted> et pas au début. 
            La tâche est donc toujours <formatted style="bold">exécutée au moins une fois</formatted>.
          </item>
          <item>On donne la <formatted style="bold">condition pour arrêter</formatted> et pas pour continuer.</item>
        </list>
      </paragraph>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
faire
    séquence d’instructions à exécuter
jusqu’à ce que condition
      </paragraph>
      <paragraph>
        La <formatted style="bold">condition</formatted> est une expression délivrant un résultat 
        <formatted style="bold">booléen</formatted> (vrai ou faux).
      </paragraph>
      <paragraph>
        Il faut que la séquence d’instructions comprise entre <formatted style="code">faire</formatted> 
        et <formatted style="code">jusqu’à ce que</formatted> contienne au moins 
        <formatted style="bold">une instruction qui modifie la condition</formatted> de telle manière 
        qu’elle puisse <formatted style="bold">devenir vraie</formatted> à un moment donné pour arrêter l’itération.
      </paragraph>
      <paragraph>
        La tâche est toujours <formatted style="bold">exécutée au moins une fois</formatted>.
      </paragraph>
      <paragraph>
        <multimedia src="../image/boucleFaire.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph title="Somme de nombres"> Après chaque nombre, on demande à l’utilisateur s’il y a encore un nombre à additionner.</paragraph>
      <paragraph cssClass="code">
// Lit des valeurs entières et retourne la somme des valeurs lues.
module sommeNombres() → entier
    encore : booléen // est-ce qu’il reste encore une valeur à additionner ?
    valeur : entier // un des termes de l’addition
    somme : entier // la somme
    somme ← 0
    faire
      lire valeur
      somme ← somme + valeur
      lire encore
    jusqu’à ce que NON encore
    retourner somme
fin module
      </paragraph>
      <paragraph>Avec cette solution, on additionne au moins une valeur.</paragraph>
      
    </look>
		</learningObject>


		<learningObject title="pour">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        On va indiquer combien de fois la tâche doit être répétée. Cela se fait au travers
        d’une <formatted style="bold">variable de contrôle</formatted> dont la valeur 
        va évoluer <formatted style="bold">à partir d’une valeur de départ jusqu’à une valeur finale</formatted>.
      </paragraph>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
pour variable de début à fin [par pas] faire
    séquence d’instructions à exécuter
fin pour
      </paragraph>
      <paragraph> est équivalent à </paragraph>
      <paragraph cssClass="code">
variable ← début
tant que variable ≤ fin faire
    séquence d’instructions à exécuter
    variable ← variable + pas // ou variable ← variable + 1 si le pas est omis.
fin tant que
      </paragraph>
      <paragraph>
        Dans ce type de structure, <formatted style="code">début</formatted>, 
        <formatted style="code">fin</formatted> et <formatted style="code">pas</formatted> 
        peuvent être des constantes, des variables ou
        des expressions (le plus souvent à valeurs entières mais on admettra parfois des réels). 
      </paragraph>
      <paragraph>
        Le <formatted style="code">pas</formatted> est facultatif, et généralement omis (dans ce cas, sa valeur par défaut est 1). 
      </paragraph>
      <paragraph>
        Ce <formatted style="code">pas</formatted> est parfois négatif, dans le cas d’un compte à rebours, 
        par exemple <formatted style="input">pour n de 10 à 1 par -1</formatted>.
      </paragraph>
      <paragraph>
        <list listStyle="ordered">
          <item>
            Quand le <formatted style="code">pas</formatted> est positif, 
            la boucle s’arrête lorsque la <formatted style="code">variable</formatted> 
            dépasse la valeur de <formatted style="code">fin</formatted>.
          </item>
          <item>
            Par contre, avec un <formatted style="code">pas</formatted> négatif, 
            la boucle s’arrête lorsque la <formatted style="code">variable</formatted> 
            prend une valeur plus petite que la valeur de <formatted style="code">fin</formatted>.
          </item>
        </list>
      </paragraph>
      <paragraph>
        On considérera qu’au cas (à éviter) où
        <list listStyle="ordered">
          <item>
            <formatted style="code">début</formatted> est strictement supérieur à <formatted style="code">fin</formatted> 
            et le <formatted style="code">pas</formatted> est positif, la séquence d’instructions n’est
            jamais exécutée (mais ce n’est pas le cas dans tous les langages de programmation !). 
          </item>
          <item>
            Idem si <formatted style="code">début</formatted> est strictement inférieur à <formatted style="code">fin</formatted> 
            mais avec un <formatted style="code">pas</formatted> négatif.
          </item>
        </list>
      </paragraph>
      <paragraph>
        Attention de <formatted style="bold">ne pas modifier</formatted> dans la séquence d’instructions une des variables de contrôle
        <formatted style="code">début</formatted>, <formatted style="code">fin</formatted> ou <formatted style="code">pas</formatted> ! 
      </paragraph>
      <paragraph>
        Il est aussi fortement <formatted style="bold">déconseillé de modifier « manuellement </formatted>» 
        la <formatted style="code">variable</formatted> 
        au sein de la boucle <formatted style="code">pour</formatted>. <newline/>
        Il ne faut pas l’initialiser en début de boucle, et ne pas s’occuper de sa modification,
         l’instruction <formatted style="code">variable ← variable + pas</formatted> étant automatique
        et implicite à chaque étape de la boucle. 
      </paragraph>
      <paragraph>
        Il est aussi déconseillé d’utiliser <formatted style="code">variable</formatted> à la sortie
        de la structure pour sans lui affecter une nouvelle valeur.
      </paragraph>
      <paragraph>
        <multimedia src="../image/bouclePour.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph cssClass="code">
// Affiche les nombres de 1 à 10.
module compterJusque10 () // version avec pour
    nb : entier
    pour nb de 1 à 10 faire // par défaut le pas est de 1
      afficher nb
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher les nombres plus petits que n">On affiche uniquement les nombres inférieurs (pas strictement) à n.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche les nombres de 1 à ce nombre.
module afficherN(n↓ : entier)
    nb : entier
    pour nb de 1 à n faire
      afficher nb
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher les nombres pairs plus petits que 10">On affiche uniquement les nombres pairs jusqu’à 10.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche les nombres pairs jusqu’à ce nombre.
// n : limite des nombres à afficher.
Exemple : si n vaut 10, les nombres pairs de 1 à 10 sont : 2, 4, 6, 8, 10.
module afficherPair (n↓ : entier)
    nb : entier
    pour nb de 2 à n par 2 faire
      afficher nb
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher les nombres pairs plus petits que n">On affiche uniquement les nombres pairs jusqu’à la limite n.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche les nombres pairs jusqu’à ce nombre.
// n : limite des nombres à afficher.
// Exemple : si n vaut 10, les nombres pairs de 1 à 10 sont : 2, 4, 6, 8, 10.
module afficherPair (n↓ : entier)
    i: entier
    pour i de 1 à n DIV 2 faire
      afficher 2 * i
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher n nombres pairs">On affiche les n premiers nombres pairs.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche ce nombre de nombres pairs.
// n: le nombre de nombres à afficher.
// Exemple : si n vaut 10, les 10 premiers nombres pairs sont : 2, 4, 6, 8, 10, 12, 14, 16, 18, 20.
module afficherPair ()
    i : entier
    pour i de 1 à n faire
      afficher 2 * i
    fin pour
fin module
    </paragraph>
    <paragraph title="Somme de nombres">L’utilisateur indique le nombre de termes au départ.</paragraph>
    <paragraph cssClass="code">
// Lit des valeurs entières et retourne la somme des valeurs lues.
module sommeNombres() → entier
    nbValeurs : entier // nb de valeurs à additionner
    valeur : entier // un des termes de l’addition
    somme : entier // la somme
    i : entier // itérateur
    somme ← 0 // la somme se construit petit à petit. Elle vaut 0 au départ
    lire nbValeurs
    pour i de 1 à nbValeurs faire
      lire valeur
      somme ← somme + valeur
    fin pour
    retourner somme
fin module
    </paragraph>
    </look>
		</learningObject>
		
		<learningObject title="Quel type de boucle choisir ?">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    En pratique, il est possible d’utiliser systématiquement la boucle tant que qui peut s’adapter
        à toutes les situations. Cependant, 
        <list listStyle="unordered">
            <item>
              il est plus clair d’utiliser la boucle <formatted style="code">pour</formatted> 
              dans les cas où le nombre d’itérations est fixé et connu à l’avance
              (par là, on veut dire que le nombre d’itérations est déterminé au moment où on arrive à la boucle). 
            </item>
            <item>
              La boucle <formatted style="code">faire</formatted> convient quant à elle dans les cas où le contenu de la boucle doit être parcouru au moins une fois,
            </item>
            <item>
              alors que dans <formatted style="code">tant que</formatted>, le nombre de parcours peut être nul si la condition initiale est fausse.
            </item>
          </list>
		  </paragraph>
		  <paragraph>
        <multimedia src="../image/boucleChoixType.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    </learningObject>

		<learningObject title="suite de nombres">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Un exemple simple pourrait être celui-ci : 
		    « <formatted style="italic">Écrire l’algorithme qui affiche les n premiers
        termes de la suite : 2, 4, 6. . . </formatted>»
      </paragraph>
      <paragraph>
        Puisqu’on doit écrire plusieurs nombres et qu’on sait exactement combien, 
        on se tournera tout naturellement vers une boucle <formatted style="code">pour</formatted>.
      </paragraph>
      <paragraph>
        Le cas le plus simple est lorsque le nombre à afficher à l’étape <formatted style="code">i</formatted> 
        peut être calculé en fonction de <formatted style="code">i</formatted> seulement. L’algorithme est alors
      </paragraph>
      <paragraph cssClass="code">
pour i de 1 à n faire
    afficher f (i)
fin pour
      </paragraph>
      <paragraph>Par exemple, pour afficher la suite des n premiers nombres pairs</paragraph>
      <paragraph cssClass="code">
module nombrePair (n↓ : entier)
    i : entier
    pour i de 1 à n faire
      afficher 2 * i
    fin pour
fin module
      </paragraph>
      <paragraph>
        Parfois, il est difficile (voire impossible) de trouver f (i). On suivra alors une autre approche
        qui revient à calculer un nombre à afficher à partir du nombre précédemment affiché (ou, plus
        exactement, de calculer le suivant à partir du nombre qu’on vient d’afficher). La structure
        générale est alors
      </paragraph>
      <paragraph cssClass="code">
nb ← {1re valeur à afficher}
pour i de 1 à n faire
    afficher nb
    nb ← {calculer ici le nb suivant}
fin pour
      </paragraph>
      <paragraph>
        Dans l’exemple de la suite paire, le 1er nombre à afficher est 
        2 et le nombre suivant se calcule en ajoutant 2 au nombre courant.
      </paragraph>
      <paragraph cssClass="code">
module suite1 (n↓ : entier)
    nb, i : entiers
    nb ← 2
    pour i de 1 à n faire
      afficher nb
      nb ← nb + 2
    fin pour
fin module
      </paragraph>
    </clarify>
    </learningObject>
    
    
		<learningObject title="3 pas en avant, 2 pas en arrière">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Dans certains cas, il n’est pas possible de déduire directement le nombre suivant en connaissant juste le nombre précédent. 
		    Prenons un exemple un peu plus compliqué pour l’illustrer.
		    « <formatted style="italic">Écrire l’algorithme qui affiche les n premiers termes de la suite : 1, 2, 3, 4, 3, 2, 3, 4, 5, 4, 3. . </formatted>. »
      </paragraph>
      <paragraph>
        Si on vient d’écrire, disons un 3, impossible sans information supplémentaire, de connaitre
        le nombre suivant. Il faudrait savoir si on est en phase d’avancement ou de recul et combien
        de pas il reste à faire dans cette direction.
      </paragraph>
      <paragraph>
        Ajoutons des variables pour retenir l’<formatted style="code">état</formatted> où on est.
      </paragraph>
      <paragraph cssClass="code">
module suite3Avant2Arrière(n↓ : entier)
    nb, nbPasRestants, direction, i : entiers
    nb ← 1
    nbPasRestants ← 3 // 3 pas
    direction ← 1 // en avant
    pour i de 1 à n faire
      afficher nb
      nb ← nb + direction // faire un pas dans la bonne direction
      nbPasRestants ← nbPasRestants - 1
      si nbPasRestants = 0 alors // il est temps de changer de direction
        direction ← -direction
        si direction = 1 alors
          nbPasRestants ← 3
        sinon
          nbPasRestants ← 2
        fin si
      fin si
    fin pour
fin module
      </paragraph>
      <paragraph>
        On obtient un algorithme plus long mais qui respecte toujours le schéma vu.
      </paragraph>
      <paragraph>
        Un conseil : essayez de respecter ce schéma et vous obtiendrez plus facilement un algorithme
        correct et lisible, également dans les cas particuliers.
      </paragraph>
    </clarify>
    </learningObject>
    
	</unit>
		
  
	<!-- =========================================================== -->
	<unit label="SelonQue" title="selon que">
	<!-- =========================================================== -->

    <entry>Avec ces structures, plusieurs branches d’exécution sont disponibles. L’ordinateur choisit la
    branche à exécuter en fonction de la valeur d’une variable (ou parfois d’une expression) ou
    de la condition qui est vraie.</entry>
    
		<learningObject title="selon que (version avec listes de valeurs)">
		<!-- =================================================== -->
		<clarify>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
selon que variable vaut
    liste_1 de valeurs séparées par des virgules :
      // instructions lorsque la valeur de la variable est dans liste_1
    liste_2 de valeurs séparées par des virgules :
      // instructions lorsque la valeur de la variable est dans liste_2
    ...
    liste_n de valeurs séparées par des virgules :
      // instructions lorsque la valeur de la variable est dans liste_n
    autres :
      // instructions lorsque la valeur de la variable
      // ne se trouve dans aucune des listes précédentes
fin selon que
      </paragraph>
      <paragraph>Notez que le cas <formatted style="code">autres</formatted> est facultatif.</paragraph>
      <paragraph>
        Dans ce type de structure, comme pour la structure <formatted style="code">si-alors-sinon</formatted>, une seule des séquences
        d’instructions sera exécutée. On veillera à ne pas faire apparaitre une même valeur dans
        plusieurs listes. Cette structure est une simplification d’écriture de plusieurs alternatives
        imbriquées.
      </paragraph>
      <paragraph>
        Elle est équivalente à : 
      </paragraph>
      <paragraph cssClass="code">
si variable = une des valeurs de la liste_1 alors
    // instructions lorsque la valeur est dans liste_1
sinon
    si variable = une des valeurs de la liste_2 alors
      // instructions lorsque la valeur est dans liste_2
    sinon
      ...
      si variable = une des valeurs de la liste_n alors
        // instructions lorsque la valeur est dans liste_n
      sinon
        // instructions lorsque la valeur de la variable
        // ne se trouve dans aucune des listes précédentes
      fin si
    fin si
fin si
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>
        Écrivons un algorithme qui lit un jour de la semaine sous forme d’un nombre entier (1 pour
        lundi, . . ., 7 pour dimanche) et qui affiche en clair ce jour de la semaine.
      </paragraph>
      <paragraph cssClass="code">
// Lit un nombre entre 1 et 7 et affiche en clair le jour de la semaine correspondant.
module jourSemaine()
    jour : entier
    lire jour
    selon que jour vaut
      1 : afficher "lundi"
      2 : afficher "mardi"
      3 : afficher "mercredi"
      4 : afficher "jeudi"
      5 : afficher "vendredi"
      6 : afficher "samedi"
      7 : afficher "dimanche"
    fin selon que
fin module
    </paragraph>
    </look>
    
    <clarify>
    <paragraph>En Java :</paragraph>
      <paragraph cssClass="code">
switch (variable){
    case val1 :
      // instructions lorsque la valeur de la variable est val1
      break;
    case val2 :
    case val3 :
    case val4 :
      // instructions lorsque la valeur de la variable est val2 ou val3 ou val4
      break;
    ...
    case valN  :
      // instructions lorsque la valeur de la variable est valN
      break;
    default :
      // instructions lorsque la valeur de la variable
      // ne se trouve dans aucune des listes précédentes
}
      </paragraph>
      <paragraph>Notez que le cas <formatted style="code">default</formatted> est facultatif.</paragraph>
      <paragraph>
        Notez le <formatted style="code">break</formatted> à la fin de chaque (groupe de)<formatted style="code"> case</formatted>.
      </paragraph>
      <paragraph>
        La variable peut être de type <formatted style="code">byte</formatted>, <formatted style="code">short</formatted>, 
        <formatted style="code">char</formatted>, <formatted style="code">int</formatted> <formatted style="code">String</formatted> et 
        les types énumérés que nous verrons plus tard.
      </paragraph>
      <paragraph>
        Elle est équivalente à : 
      </paragraph>
      <paragraph cssClass="java">
if (variable == val1){
      // instructions lorsque la valeur de la variable est val1
} else if (variable ==  val2 || variable ==  val3 || variable == val4){
      // instructions lorsque la valeur de la variable est val2 ou val3 ou val4
} else if (variable == valN){
      // instructions lorsque la valeur de la variable est valN
} else {
      // instructions lorsque la valeur de la variable
      // ne se trouve dans aucune des listes precedentes
}      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph cssClass="java">
import java.util.Scanner;
public class Test{
  public static void main(String[] args){
      Scanner clavier = new Scanner(System.in);
      String produit = clavier.next();
      switch(produit) {
        case "Coca" :
        case "Sprite" :
        case "Fanta" :
        prixDistributeur = 60;
        break;
      case "IceTea" :
        prixDistributeur = 70;
        break;
      default :
        prixDistributeur = 0;
        break;
      }
      System.out.println(prixDistributeur);
    }
}
      </paragraph>
    </look>
		</learningObject>


		<learningObject title="selon que (version avec conditions)">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
selon que
    condition_1 :
      // instructions lorsque la condition_1 est vraie
    condition_2 :
      // instructions lorsque la condition_2 est vraie
    ...
    condition_n :
      // instructions lorsque la condition_n est vraie
    autres :
      // instructions à exécuter quand aucune
      // des conditions précédentes n’est vérifiée
fin selon que
      </paragraph>
      <paragraph>
        Comme précédemment, une et une seule des séquences d’instructions est exécutée. On
        veillera à ce que les conditions ne se « recouvrent » pas, c’est-à-dire que deux d’entre elles
        ne soient jamais vraies simultanément. 
      </paragraph>
      <paragraph>C’est équivalent à : </paragraph>
      <paragraph cssClass="code">
si condition_1 alors
    // instructions lorsque la condition_1 est vraie
sinon
    si condition_2 alors
      // instructions lorsque la condition_2 est vraie
    sinon
      ...
      si condition_n alors
        // instructions lorsque la condition_n est vraie
      sinon
        // instructions à exécuter quand aucune
        // des conditions précédentes n’est vérifiée
      fin si
    fin si
fin si
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph cssClass="code">
// Lit un nombre et affiche si ce nombre est strictement positif , strictement négatif ou nul.
module signeNombre()
    nb : entier
    lire nb
    selon que 
      nb <![CDATA[<]]> 0 :
        afficher "le nombre", nb, " est négatif"
      nb <![CDATA[>]]> 0 :
        afficher "le nombre", nb, " est positif"
      autres : 
        afficher "le nombre", nb, " est nul"
    fin selon que
fin module
    </paragraph>
    </look>
    
    <clarify>
		  <paragraph>En Java :</paragraph>
		  <paragraph>Il n'existe pas de <formatted style="code">switch</formatted> avec condition, 
		  il faut l'écrire comme une succession de <formatted style="code">if</formatted>.</paragraph>
      <paragraph cssClass="java">
if (condition_1){
      // instructions lorsque la condition_1 est vraie
} else if (condition_2){
      // instructions lorsque la condition_2 est vraie
} ... 
} else if (condition_n){
      // instructions lorsque la condition_n est vraie
} else {
      // instructions a executer quand aucune
      // des conditions precedentes n est verifiee
}
      </paragraph>
    </clarify>
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph cssClass="java">
import java. util .Scanner;
public class Test {
    public static void main(String [] args) {
      Scanner clavier = new Scanner(System.in);
      int nb = clavier.nextInt();
      if (nb>0) {
        System.out. println (" positif ");
      } else if (nb==0) {
        System.out. println ("nul");
      } else {
        System.out. println (" negatif ");
      }
    }
}
    </paragraph>
    </look>
		</learningObject>

	</unit>
	
	
	<!-- =================================================================== -->
	<unit label="Exercices" title="Exercices">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Maintenant, mettons tout ça en pratique.
      </paragraph>
    </entry>
    
    <learningObject title="Compréhension d’algorithme">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des algorithmes donnés. 
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher ?
              </question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="code">
module boucle1 ()
    x : entier
    x ← 0
    tant que x <![CDATA[<]]> 12 faire
      x ← x+2
    fin tant que
    afficher x
fin module
				</paragraph>
				            <gap answers="12">12</gap> 
                  </item>
									<item>
										<paragraph cssClass="code">
module exerciceB()
    a,b,c : entier
    lire b,a
    si a > b alors
      c ← a DIV b
    sinon
      c ← b MOD a
    fin si
    afficher c
fin module
				</paragraph>
				            <paragraph>Si les nombres lus sont respectivement 2 et 3 ? </paragraph>
				            <gap answers="1">1</gap> 
									<paragraph>Si les nombres lus sont respectivement 4 et 1 ? </paragraph>
									  <gap answers="0">0</gap> 
                  </item>
									<item>
										<paragraph cssClass="code">
module exerciceC ()
    x1, x2 : entier
    ok : booléen
    lire x1, x2
    ok ← x1 > x2
    si ok alors
      ok ← ok ET x1 = 4
    sinon
      ok ← ok OU x2 = 3
    fin si
    si ok alors
      x1 ← x1 * 1000
    fin si
    afficher x1 + x2
fin module
				</paragraph>
				            <paragraph>Si les nombres lus sont respectivement 2 et 3 ? </paragraph>
				            <gap answers="2003">2003</gap> 
									<paragraph>Si les nombres lus sont respectivement 4 et 1 ? </paragraph>
									  <gap answers="4001">4001</gap> 
                  </item>
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
        </paragraph>
      </act>
    </learningObject>
      
    <learningObject title="Compréhension de codes Java">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des codes Java donnés. 
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher si à chaque fois les deux nombres lus au départ sont successivement 2, 3 et 4 ?
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice1 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        int nb3 = clavier.nextInt();
        if (nb1 <![CDATA[<]]> nb2){
          System.out.print(nb1);
        } else {
          System.out.print(nb2);
        } 
    }
}
        </paragraph>
				            <gap answers="2">2</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice2 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        int nb3 = clavier.nextInt();
        if (nb1 <![CDATA[>]]> nb2 <![CDATA[&&]]> nb1 <![CDATA[>]]> nb3){
          System.out.print(nb1);
        } else {
            if (nb2 <![CDATA[>]]> nb3){
              System.out.print(nb2);
            } else {
              System.out.print(nb3);
            }
        } 
    }
}
        </paragraph>
				            <gap answers="4">4</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice3 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        int nb3 = clavier.nextInt();
        switch (nb1){
          case 1 : System.out.print("premier"); break;
          case 2 : System.out.print("deuxieme"); break;
          case 3 : System.out.print("troisieme"); break;
          default : System.out.print("pas dans le trio");
        } 
    }
}
        </paragraph>
				            <gap answers="deuxième">deuxième</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice3 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        int nb3 = clavier.nextInt();
        switch (nb1){
          case 1 : System.out.print("premier");
          case 2 : System.out.print("deuxieme");
          case 3 : System.out.print("troisieme");
          default : System.out.print("pas dans le trio");
        } 
    }
}
        </paragraph>
				            <gap answers="premierdeuxiemetroisiemepas dans le trio">premierdeuxiemetroisiemepas dans le trio</gap> 
									</item>  
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
        </paragraph>
      </act>
    </learningObject>
    
    <learningObject title="À vous de jouer...">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Il est temps de se lancer et d’écrire vos premiers modules et programmes Java correspondant. 
          Voici quelques conseils pour vous guider dans la résolution de tels problèmes :
          <list listStyle="unordered">
            <item>il convient d’abord de bien comprendre le problème posé ; assurez-vous qu’il est parfaitement spécifié ;</item>
            <item>déclarez ensuite les variables (et leur type) qui interviennent dans l’algorithme ; les noms des variables risquant de ne pas être suffisamment explicites ;</item>
            <item><formatted style="bold">mettez en évidence les variables « données », les variables « résultats » et les variables de travail ;</formatted></item>
            <item>n’hésitez pas à faire une ébauche de résolution en français avant d’élaborer l’algorithme définitif pseudo-codé.</item>
            <item>Écrivez la partie algorithmique <formatted style="bold">AVANT</formatted> de vous lancer dans la programmation en Java.</item>
          </list>
        </paragraph>
        
        <paragraph>
        Écrivez les algorithmes et codez les programmes Java correspondant qui 
          <list listStyle="ordered">
            <item>étant donné deux nombres quelconques, recherche et affiche le plus
              grand des deux. Attention ! On ne veut pas savoir si c’est le premier ou le deuxième qui est
              le plus grand mais bien quelle est cette plus grande valeur. Le problème est donc bien défini
              même si les deux nombres sont identiques.
            </item>
            <item>étant donné trois nombres quelconques, recherche et affiche le plus grand des trois.</item>
            <item>affiche un message indiquant si un entier est strictement négatif, nul ou strictement positif.</item>
            <item>étant donné trois nombres, recherche et affiche si le premier des 
            trois appartient à l’intervalle donné par le plus petit et le plus grand des deux autres (bornes exclues). 
            Qu’est-ce qui change si on inclut les bornes ?</item>
            <item>étant donné une équation du deuxième degré, déterminée par le coefficient de x² , le coefficient de x et le terme indépendant, 
            recherche et affiche la (ou les) racine(s) de l’équation (ou un message adéquat s’il n’existe pas de racine réelle).</item>
            <item>à partir d’un moment exprimé par 2 entiers, heure et minute, affiche le moment qu’il sera une minute plus tard.</item>
            <item>vérifie si une année est bissextile. Pour rappel, les années bissextiles sont les années multiples de 4.
             Font exception, les multiples de 100 (sauf les multiples de 400 qui sont bien bissextiles). Ainsi 2012 et 2400 sont bissextile mais pas 2010 ni 2100.</item>
          </list>
        </paragraph>
        
        <paragraph title="Stationnement alternatif">
          Dans une rue où se pratique le stationnement alternatif, du 1 au 15 du mois, on se gare du côté des maisons ayant un numéro impair, 
          et le reste du mois, on se gare de l’autre côté.
          Écrivez un algorithme et le code java correspondant qui, sur base de la date du jour et du numéro de maison devant laquelle
          vous vous êtes arrêté, indique si vous êtes bien stationné ou non.
        </paragraph>
        
        <paragraph title="La fièvre monte">
          Chez l'humain la température corporelle normale moyenne est de 37 °C (entre 36,5 °C et 37,5 °C selon les individus). 
          La fièvre est définie par une température rectale au repos supérieure ou égale à 38,0 °C. 
          Une fièvre au-delà de 40 °C  est considérée comme un risque de santé majeur et immédiat. 
          Lorsque la fièvre est modérée (de 37,7 °C à 37,9 °C), on parle de fébricule.<newLine/>
          [Wikipedia]
        </paragraph>
        <paragraph>
          Écrivez un module fièvre qui lit une température au clavier et qui affiche si le patient a de la
          température (supérieure ou égale à 38,0°C) ET si cette cette fièvre est modérée (entre 38,0°C 
          et 40,0°C) ou à risque (strictement supérieur à 40,0°C). 
          Rien ne doit être affiché si le patient n'a pas de fièvre.
        </paragraph>
        <paragraph>Écrivez le code java correspondant.</paragraph>
        
        <paragraph title="Taxes communales">
          Dans ma commune, les taxes communales des enlèvements des immondices s’élèvent à
          <list listStyle="unordered">
            <item>80€ pour une personne isolée ;</item>
            <item>135€ pour une famille de 2 ou 3 personnes ;</item>
            <item>175€ pour une famille de 4 personnes ou plus.</item>
          </list>
          Écrivez un module qui lit le nombre de personnes composant la famille et qui affiche le prix de la taxe à payer.
        </paragraph>
        <paragraph>Écrivez le code java correspondant.</paragraph>
        
        <paragraph title="Au cinéma">
          À Bruxelles, lors de chaque projection cinématographique, une taxe de 0,5€ est
          prélevée sur le prix du billet de chaque spectateur.
          <list listStyle="unordered">
            <item>Écrivez un module qui lit le nombre de spectateurs et qui affiche le prix de la taxe à payer.</item>
            <item>Écrivez le code java correspondant.</item>
            <item>
              Si le film projeté est un documentaire, aucune taxe n’est prélevée. 
              Écrivez un module qui lit le nombre de spectateurs et un booléen (à vrai
              si le film est un documentaire et faux sinon) et qui affiche le prix de la taxe
              à payer.
            </item>
            <item>Écrivez le code java correspondant.</item>
          </list>
        </paragraph>
      </act>
    </learningObject>
  </unit>
</lesson>
