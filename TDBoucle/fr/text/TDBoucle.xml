<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="../../../_templates/java/latex.xsl"?>
<lesson xmlns="http://www.elml.ch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.elml.ch ../../../_config/validate.xsd" 
	label="TDBoucle" title="TD Boucles">
	
	<entry>
		<paragraph>
			Voyons ici comment incorporer des boucles, les structures répétitives, dans nos codes et comment les utiliser à bon escient.
    </paragraph>
	</entry>
	
	<!-- =========================================================== -->
	<unit label="Boucles" title="Les boucles">
	<!-- =========================================================== -->

    <entry>
      <paragraph>
        Si on veut faire effectuer un travail répétitif, il faut indiquer deux choses :
        <list listStyle="ordered">
          <item>Le travail à répéter</item>
          <item>La manière de continuer la répétition ou de l’arrêter.</item>
        </list>
		</paragraph>
    </entry>
    
		<learningObject title="tant que">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        Le « <formatted style="code">tant que</formatted> » est une structure 
        qui demande à l’exécutant de répéter une tâche (une ou
        plusieurs instructions) tant qu’une condition donnée est vraie.
      </paragraph>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
tant que condition faire
    séquence d’instructions à exécuter
fin tant que
      </paragraph>
      <paragraph>
        La <formatted style="bold">condition</formatted> est une expression délivrant un résultat 
        <formatted style="bold">booléen</formatted> (vrai ou faux).
      </paragraph>
      <paragraph>
        Il faut qu’il y ait dans la séquence d’instructions comprise entre <formatted style="code">tant que</formatted>
        et <formatted style="code">fin tant que</formatted> au moins <formatted style="bold">une instruction qui 
        modifie</formatted> une des composantes de <formatted style="bold">la condition</formatted>
        de telle manière qu’elle puisse <formatted style="bold">devenir fausse</formatted> à un moment donné. Dans le cas contraire,
        la condition reste <formatted style="bold">indéfiniment vrai</formatted>e et la boucle va tourner sans fin, c’est ce qu’on appelle
        une <formatted style="bold">boucle infinie</formatted>.
      </paragraph>
      <paragraph>
        Si la condition est fausse dès le début, la tâche n’est jamais exécutée.
      </paragraph>
      <paragraph>
        <multimedia src="../image/boucleTq.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph title="Afficher les nombres plus petits que 10">On affiche uniquement les nombres inférieurs (pas strictement) à 10 .</paragraph>
      <paragraph cssClass="code">
// Affiche les nombres de 1 à 10.
module compterJusque10 () // version avec tant que
    nb : entier
    nb ← 1 // c’est le premier nombre à afficher
    tant que nb ≤ 10 faire // c’est le premier nombre à afficher
      afficher nb  // on affiche la valeur de la variable nb
      nb ← nb + 1 // on passe au nombre suivant
    fin tant que
fin module
      </paragraph>
      <paragraph title="Somme de nombres"> Après chaque nombre, on demande à l’utilisateur s’il y a encore un nombre à additionner.</paragraph>
      <paragraph cssClass="code">
// Lit des valeurs entières et retourne la somme des valeurs lues.
module sommeNombres() → entier
    valeur : entier // un des termes de l’addition
    somme : entier // la somme
    somme ← 0
    lire valeur
    tant que valeur ≥ 0 faire
      somme ← somme + valeur
      lire valeur // remarquer l’endroit où on lit une valeur.
    fin tant que
retourner somme
fin module
      </paragraph>
    </look>
		</learningObject>


		<learningObject title="faire - jusqu’à ce que">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        Cette structure est très proche du « <formatted style="code">tant que</formatted> » à deux différences près :
        <list listStyle="ordered">
          <item>
            Le <formatted style="bold">test</formatted> est fait <formatted style="bold">à la fin</formatted> et pas au début. 
            La tâche est donc toujours <formatted style="bold">exécutée au moins une fois</formatted>.
          </item>
          <item>On donne la <formatted style="bold">condition pour arrêter</formatted> et pas pour continuer.</item>
        </list>
      </paragraph>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
faire
    séquence d’instructions à exécuter
jusqu’à ce que condition
      </paragraph>
      <paragraph>
        La <formatted style="bold">condition</formatted> est une expression délivrant un résultat 
        <formatted style="bold">booléen</formatted> (vrai ou faux).
      </paragraph>
      <paragraph>
        Il faut que la séquence d’instructions comprise entre <formatted style="code">faire</formatted> 
        et <formatted style="code">jusqu’à ce que</formatted> contienne au moins 
        <formatted style="bold">une instruction qui modifie la condition</formatted> de telle manière 
        qu’elle puisse <formatted style="bold">devenir vraie</formatted> à un moment donné pour arrêter l’itération.
      </paragraph>
      <paragraph>
        La tâche est toujours <formatted style="bold">exécutée au moins une fois</formatted>.
      </paragraph>
      <paragraph>
        <multimedia src="../image/boucleFaire.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph title="Somme de nombres"> Après chaque nombre, on demande à l’utilisateur s’il y a encore un nombre à additionner.</paragraph>
      <paragraph cssClass="code">
// Lit des valeurs entières et retourne la somme des valeurs lues.
module sommeNombres() → entier
    encore : booléen // est-ce qu’il reste encore une valeur à additionner ?
    valeur : entier // un des termes de l’addition
    somme : entier // la somme
    somme ← 0
    faire
      lire valeur
      somme ← somme + valeur
      lire encore
    jusqu’à ce que NON encore
    retourner somme
fin module
      </paragraph>
      <paragraph>Avec cette solution, on additionne au moins une valeur.</paragraph>
      
    </look>
		</learningObject>


		<learningObject title="pour">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        On va indiquer combien de fois la tâche doit être répétée. Cela se fait au travers
        d’une <formatted style="bold">variable de contrôle</formatted> dont la valeur 
        va évoluer <formatted style="bold">à partir d’une valeur de départ jusqu’à une valeur finale</formatted>.
      </paragraph>
		  <paragraph>En pseudo-code :</paragraph>
      <paragraph cssClass="code">
pour variable de début à fin [par pas] faire
    séquence d’instructions à exécuter
fin pour
      </paragraph>
      <paragraph> est équivalent à </paragraph>
      <paragraph cssClass="code">
variable ← début
tant que variable ≤ fin faire
    séquence d’instructions à exécuter
    variable ← variable + pas // ou variable ← variable + 1 si le pas est omis.
fin tant que
      </paragraph>
      <paragraph>
        Dans ce type de structure, <formatted style="code">début</formatted>, 
        <formatted style="code">fin</formatted> et <formatted style="code">pas</formatted> 
        peuvent être des constantes, des variables ou
        des expressions (le plus souvent à valeurs entières mais on admettra parfois des réels). 
      </paragraph>
      <paragraph>
        Le <formatted style="code">pas</formatted> est facultatif, et généralement omis (dans ce cas, sa valeur par défaut est 1). 
      </paragraph>
      <paragraph>
        Ce <formatted style="code">pas</formatted> est parfois négatif, dans le cas d’un compte à rebours, 
        par exemple <formatted style="input">pour n de 10 à 1 par -1</formatted>.
      </paragraph>
      <paragraph>
        <list listStyle="ordered">
          <item>
            Quand le <formatted style="code">pas</formatted> est positif, 
            la boucle s’arrête lorsque la <formatted style="code">variable</formatted> 
            dépasse la valeur de <formatted style="code">fin</formatted>.
          </item>
          <item>
            Par contre, avec un <formatted style="code">pas</formatted> négatif, 
            la boucle s’arrête lorsque la <formatted style="code">variable</formatted> 
            prend une valeur plus petite que la valeur de <formatted style="code">fin</formatted>.
          </item>
        </list>
      </paragraph>
      <paragraph>
        On considérera qu’au cas (à éviter) où
        <list listStyle="ordered">
          <item>
            <formatted style="code">début</formatted> est strictement supérieur à <formatted style="code">fin</formatted> 
            et le <formatted style="code">pas</formatted> est positif, la séquence d’instructions n’est
            jamais exécutée (mais ce n’est pas le cas dans tous les langages de programmation !). 
          </item>
          <item>
            Idem si <formatted style="code">début</formatted> est strictement inférieur à <formatted style="code">fin</formatted> 
            mais avec un <formatted style="code">pas</formatted> négatif.
          </item>
        </list>
      </paragraph>
      <paragraph>
        Attention de <formatted style="bold">ne pas modifier</formatted> dans la séquence d’instructions une des variables de contrôle
        <formatted style="code">début</formatted>, <formatted style="code">fin</formatted> ou <formatted style="code">pas</formatted> ! 
      </paragraph>
      <paragraph>
        Il est aussi fortement <formatted style="bold">déconseillé de modifier « manuellement </formatted>» 
        la <formatted style="code">variable</formatted> 
        au sein de la boucle <formatted style="code">pour</formatted>. <newline/>
        Il ne faut pas l’initialiser en début de boucle, et ne pas s’occuper de sa modification,
         l’instruction <formatted style="code">variable ← variable + pas</formatted> étant automatique
        et implicite à chaque étape de la boucle. 
      </paragraph>
      <paragraph>
        Il est aussi déconseillé d’utiliser <formatted style="code">variable</formatted> à la sortie
        de la structure pour sans lui affecter une nouvelle valeur.
      </paragraph>
      <paragraph>
        <multimedia src="../image/bouclePour.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph cssClass="code">
// Affiche les nombres de 1 à 10.
module compterJusque10 () // version avec pour
    nb : entier
    pour nb de 1 à 10 faire // par défaut le pas est de 1
      afficher nb
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher les nombres plus petits que n">On affiche uniquement les nombres inférieurs (pas strictement) à n.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche les nombres de 1 à ce nombre.
module afficherN(n↓ : entier)
    nb : entier
    pour nb de 1 à n faire
      afficher nb
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher les nombres pairs plus petits que 10">On affiche uniquement les nombres pairs jusqu’à 10.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche les nombres pairs jusqu’à ce nombre.
// n : limite des nombres à afficher.
Exemple : si n vaut 10, les nombres pairs de 1 à 10 sont : 2, 4, 6, 8, 10.
module afficherPair (n↓ : entier)
    nb : entier
    pour nb de 2 à n par 2 faire
      afficher nb
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher les nombres pairs plus petits que n">On affiche uniquement les nombres pairs jusqu’à la limite n.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche les nombres pairs jusqu’à ce nombre.
// n : limite des nombres à afficher.
// Exemple : si n vaut 10, les nombres pairs de 1 à 10 sont : 2, 4, 6, 8, 10.
module afficherPair (n↓ : entier)
    i: entier
    pour i de 1 à n DIV 2 faire
      afficher 2 * i
    fin pour
fin module
    </paragraph>
    <paragraph title="Afficher n nombres pairs">On affiche les n premiers nombres pairs.</paragraph>
    <paragraph cssClass="code">
// Reçoit un nombre et affiche ce nombre de nombres pairs.
// n: le nombre de nombres à afficher.
// Exemple : si n vaut 10, les 10 premiers nombres pairs sont : 2, 4, 6, 8, 10, 12, 14, 16, 18, 20.
module afficherPair ()
    i : entier
    pour i de 1 à n faire
      afficher 2 * i
    fin pour
fin module
    </paragraph>
    <paragraph title="Somme de nombres">L’utilisateur indique le nombre de termes au départ.</paragraph>
    <paragraph cssClass="code">
// Lit des valeurs entières et retourne la somme des valeurs lues.
module sommeNombres() → entier
    nbValeurs : entier // nb de valeurs à additionner
    valeur : entier // un des termes de l’addition
    somme : entier // la somme
    i : entier // itérateur
    somme ← 0 // la somme se construit petit à petit. Elle vaut 0 au départ
    lire nbValeurs
    pour i de 1 à nbValeurs faire
      lire valeur
      somme ← somme + valeur
    fin pour
    retourner somme
fin module
    </paragraph>
    </look>
		</learningObject>
		
		<learningObject title="Quel type de boucle choisir ?">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    En pratique, il est possible d’utiliser systématiquement la boucle tant que qui peut s’adapter
        à toutes les situations. Cependant, 
        <list listStyle="unordered">
            <item>
              il est plus clair d’utiliser la boucle <formatted style="code">pour</formatted> 
              dans les cas où le nombre d’itérations est fixé et connu à l’avance
              (par là, on veut dire que le nombre d’itérations est déterminé au moment où on arrive à la boucle). 
            </item>
            <item>
              La boucle <formatted style="code">faire</formatted> convient quant à elle dans les cas où le contenu de la boucle doit être parcouru au moins une fois,
            </item>
            <item>
              alors que dans <formatted style="code">tant que</formatted>, le nombre de parcours peut être nul si la condition initiale est fausse.
            </item>
          </list>
		  </paragraph>
		  <paragraph>
        <multimedia src="../image/boucleChoixType.jpg" type="jpeg" />
      </paragraph>
    </clarify>
    </learningObject>

    <learningObject title="Sentinelle">
		<!-- ================================================ -->
		<clarify>
      Quand l’utilisateur entre une valeur spéciale pour indiquer la fin 
      (d'une boucle <formatted style="code">tant que</formatted> ou <formatted style="code">faire</formatted>), 
      on parle de<formatted style="bold"> valeur sentinelle</formatted>.
      Ceci n’est possible que si cette valeur sentinelle ne peut pas être un terme valide. 
      Par exemple, si on veut additionner des nombres positifs uniquement, la valeur -1 peut
      servir de valeur sentinelle. Mais sans limite sur les nombres à additionner (positifs, négatifs
      ou nuls) il n’est pas possible de choisir une sentinelle.
    </clarify>
    </learningObject>
    
		<learningObject title="suite de nombres">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Un exemple simple pourrait être celui-ci : 
		    « <formatted style="italic">Écrire l’algorithme qui affiche les n premiers
        termes de la suite : 2, 4, 6. . . </formatted>»
      </paragraph>
      <paragraph>
        Puisqu’on doit écrire plusieurs nombres et qu’on sait exactement combien, 
        on se tournera tout naturellement vers une boucle <formatted style="code">pour</formatted>.
      </paragraph>
      <paragraph>
        Le cas le plus simple est lorsque le nombre à afficher à l’étape <formatted style="code">i</formatted> 
        peut être calculé en fonction de <formatted style="code">i</formatted> seulement. L’algorithme est alors
      </paragraph>
      <paragraph cssClass="code">
pour i de 1 à n faire
    afficher f (i)
fin pour
      </paragraph>
      <paragraph>Par exemple, pour afficher la suite des n premiers nombres pairs</paragraph>
      <paragraph cssClass="code">
module nombrePair (n↓ : entier)
    i : entier
    pour i de 1 à n faire
      afficher 2 * i
    fin pour
fin module
      </paragraph>
      <paragraph>
        Parfois, il est difficile (voire impossible) de trouver f (i). On suivra alors une autre approche
        qui revient à calculer un nombre à afficher à partir du nombre précédemment affiché (ou, plus
        exactement, de calculer le suivant à partir du nombre qu’on vient d’afficher). La structure
        générale est alors
      </paragraph>
      <paragraph cssClass="code">
nb ← {1re valeur à afficher}
pour i de 1 à n faire
    afficher nb
    nb ← {calculer ici le nb suivant}
fin pour
      </paragraph>
      <paragraph>
        Dans l’exemple de la suite paire, le 1er nombre à afficher est 
        2 et le nombre suivant se calcule en ajoutant 2 au nombre courant.
      </paragraph>
      <paragraph cssClass="code">
module suite1 (n↓ : entier)
    nb, i : entiers
    nb ← 2
    pour i de 1 à n faire
      afficher nb
      nb ← nb + 2
    fin pour
fin module
      </paragraph>
    </clarify>
    </learningObject>
    
    
		<learningObject title="3 pas en avant, 2 pas en arrière">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Dans certains cas, il n’est pas possible de déduire directement le nombre suivant en connaissant juste le nombre précédent. 
		    Prenons un exemple un peu plus compliqué pour l’illustrer.
		    « <formatted style="italic">Écrire l’algorithme qui affiche les n premiers termes de la suite : 1, 2, 3, 4, 3, 2, 3, 4, 5, 4, 3. . </formatted>. »
      </paragraph>
      <paragraph>
        Si on vient d’écrire, disons un 3, impossible sans information supplémentaire, de connaitre
        le nombre suivant. Il faudrait savoir si on est en phase d’avancement ou de recul et combien
        de pas il reste à faire dans cette direction.
      </paragraph>
      <paragraph>
        Ajoutons des variables pour retenir l’<formatted style="code">état</formatted> où on est.
      </paragraph>
      <paragraph cssClass="code">
module suite3Avant2Arrière(n↓ : entier)
    nb, nbPasRestants, direction, i : entiers
    nb ← 1
    nbPasRestants ← 3 // 3 pas
    direction ← 1 // en avant
    pour i de 1 à n faire
      afficher nb
      nb ← nb + direction // faire un pas dans la bonne direction
      nbPasRestants ← nbPasRestants - 1
      si nbPasRestants = 0 alors // il est temps de changer de direction
        direction ← -direction
        si direction = 1 alors
          nbPasRestants ← 3
        sinon
          nbPasRestants ← 2
        fin si
      fin si
    fin pour
fin module
      </paragraph>
      <paragraph>
        On obtient un algorithme plus long mais qui respecte toujours le schéma vu.
      </paragraph>
      <paragraph>
        Un conseil : essayez de respecter ce schéma et vous obtiendrez plus facilement un algorithme
        correct et lisible, également dans les cas particuliers.
      </paragraph>
    </clarify>
    </learningObject>
    
	</unit>
		
  
	
	<!-- =================================================================== -->
	<unit label="Exercices" title="Exercices">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Maintenant, mettons tout ça en pratique.
      </paragraph>
    </entry>
    
    <learningObject title="Compréhension d’algorithme">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des algorithmes donnés. 
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher ?
              </question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="code">
module boucle1 ()
    x : entier
    x ← 0
    tant que x <![CDATA[<]]> 12 faire
      x ← x+2
    fin tant que
    afficher x
fin module
				</paragraph>
				            <gap answers="12">12</gap> 
                  </item>
									<item>
										<paragraph cssClass="code">
module boucle2 ()
    ok : booléen
    x : entier
    ok ← vrai
    x ← 5
    tant que ok faire
      x ← x+7
      ok ← x MOD 11 ≠ 0
    fin tant que
    afficher x
fin module
				</paragraph>
				            <gap answers="33">33</gap> 
                  </item>
									<item>
										<paragraph cssClass="code">
module boucle3 ()
    ok : booléen
    cpt, x : entiers
    x ← 10
    cpt ← 0
    ok ← vrai
    tant que ok ET cpt <![CDATA[<]]> 3 faire
      si x MOD 2 = 0 alors
        x ← x+1
        ok ← x <![CDATA[<]]> 20
      sinon
        x ← x+3
        cpt ← cpt + 1
      fin si
    fin tant que
    afficher x
fin module
				</paragraph>
				            <gap answers="22">22</gap> 
                  </item>
                  <item>
										<paragraph cssClass="code">
module boucle4 ()
    pair, grand : booléens
    p, x : entiers
    x ← 1
    p ← 1
    faire
      p ← 2*p
      x ← x+p
      pair ← x MOD 2 = 0
      grand ← x > 15
    jusqu’à ce que pair OU grand
    afficher x
fin module
				</paragraph>
				            <gap answers="31">31</gap> 
                  </item>
                  <item>
										<paragraph cssClass="code">
module boucle5 ()
    i, x : entiers
    ok : booléen
    x ← 3
    ok ← vrai
    pour i de 1 à 5 faire
      x ← x+i
      ok ← ok ET (x MOD 2 = 0)
    fin pour
    si ok alors
      afficher x
    sinon
      afficher 2 * x
    fin si
fin module
				</paragraph>
				            <gap answers="36">36</gap> 
                  </item>
                  <item>
										<paragraph cssClass="code">
module boucle6 ()
    i, j, fin : entiers
    pour i de 1 à 3 faire
      fin ← 6 * i - 11
      pour j de 1 à fin par 3 faire
        afficher 10 * i + j
      fin pour
    fin pour
fin module
				</paragraph>
				            <gap answers="21 31 34 37">21 31 34 37</gap> 
                  </item>
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
        </paragraph>
      </act>
    </learningObject>
      
    <learningObject title="Compréhension de codes Java">
    <!-- ============================================================ -->
      <act>
				<selfCheck title="Instructions répétitives" shuffle="no">
					<multipleChoice>
						<question>
							Quelles instructions répétitives sont correctes parmi les suivantes? <newLine/>
							Expliquez pourquoi les autres ne le sont pas.
						</question>
						<answer feedback="" correct="no">proposition 1
							<paragraph cssClass="java">
While ( condition ) {
	// instructions
}							</paragraph>

						</answer>
						<answer feedback="" correct="no">proposition 2
							<paragraph cssClass="java">
do while ( condition ) {
	// instructions
}							</paragraph>
						</answer>
						<answer feedback="" correct="yes">proposition 3
							<paragraph cssClass="java">
while ( true ) {
	// instructions
}							</paragraph>
						</answer>
						<answer feedback="" correct="no">proposition 4
							<paragraph cssClass="java">
while ( true ) do {
	// instructions
}							</paragraph>
						</answer>
						<answer feedback="" correct="no">proposition 5
							<paragraph cssClass="java">
FOR ( int i=0; i&lt;=10; i=i+2 ) DO {
	// instructions
}							</paragraph>
						</answer>
						<answer feedback="" correct="yes">proposition 6
							<paragraph cssClass="java">
for ( int i=0; i&lt;=10; i=i+2 ) {
	// instructions
}							</paragraph>
						</answer>
						<answer feedback="" correct="no">proposition 7
							<paragraph cssClass="java">
for ( int i=0; i&lt;=10; i=i+2 ) do {
	// instructions
}							</paragraph>
						</answer>
						<answer feedback="" correct="yes">proposition 8
							<paragraph cssClass="java">
for ( int i=9; i&gt;=0; i=i-2 ) {
	// instructions
}							</paragraph>
						</answer>
					</multipleChoice>
				</selfCheck>
				
				<selfCheck title="Activité 'remplir les blancs'" shuffle="yes">
					<fillInBlanks>
						<question></question>
						<gapText>
							<paragraph>
								Quel opérateur de comparaison Java représente la relation suivante? 
							</paragraph>
							<list listStyle="ordered">
								<item>"est égal à" ?                     <gap answers="">==</gap></item>
								<item>"est différent de" ?               <gap answers="">!=</gap></item>
							</list>
							<paragraph>
								Quel opérateur booléen Java représente l'opérateur logique suivant? 
							</paragraph>
							<list listStyle="ordered">
								<item>le ET :  <gap answers="">&amp;&amp;</gap></item>
								<item>le OU :  <gap answers="">||</gap></item>
								<item>le NON : <gap answers="">!</gap></item>
							</list>
						</gapText>
						<solution/>
					</fillInBlanks>
				</selfCheck>

				<paragraph title="Expérience" icon="icon_experiment">
					Indiquez l'affichage obtenu par ce code.
				</paragraph>
				<selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher ?
              </question>
							<gapText> 
                <paragraph cssClass="java">
<![CDATA[public class Boucles {

	public static void main ( String[] args ) {
		int facteur;
		final int VALEUR = 3;
	
		for (facteur = 1 ; facteur <= 10 ; facteur++){		
			System.out.print(facteur*VALEUR+" ");
		}
		System.out.println();
	}
}]]>			</paragraph>
				            <gap answers="">3 6 9 12 15 18 21 24 27 30 </gap> 
                </gapText>
              </fillInBlanks>
            </selfCheck>
				

				<paragraph title="Exercice Tant que" icon="act">
					Écrivez en Java l'algorithme suivant.
				</paragraph>
				<paragraph cssClass="code">
<![CDATA[MODULE Test

    nb, produit : Entier
    produit ← 1 

    LIRE nb
    TANT QUE nb ≠ 0 FAIRE
        produit ← produit * nb
        LIRE nb 
    FIN TANT QUE
    AFFICHER produit
    
FIN MODULE
]]>			    </paragraph>
				<popup title="la solution" visible="online"> 
					<paragraph cssClass="java">
<![CDATA[import java.util.Scanner;
public class Test {

	public static void main(String [] args) {
	
		Scanner clavier = new Scanner(System.in); 
		int nb; 
		int produit;
		produit = 1; 
		System.out.println("Entrez la valeur du nombre"); 
		nb = clavier.nextInt();
		while (nb != 0) {
			produit = produit * nb;
			System.out.println("Entrez la valeur du nombre"); 
			nb = clavier.nextInt();			
		} 		
		System.out.println("Le produit vaut " + produit);	
	}
}]]>				</paragraph>
				</popup>

				<paragraph title="Exercice Pour" icon="act">
					Écrivez en Java l'algorithme suivant.
				</paragraph>
				<paragraph cssClass="code">
<![CDATA[MODULE Test

    nb: Entier
    i : Entier

    LIRE nb
    POUR i DE 1 A nb FAIRE
        AFFICHER i
    FIN POUR

FIN MODULE
]]>			     </paragraph>

				<popup title="la solution" visible="online"> 
					<paragraph cssClass="java">
<![CDATA[import java.util.Scanner;
public class Test {

    public static void main(String [] args){
	
        Scanner clavier = new Scanner(System.in); 
        int nombre1; 
	
        nombre1 = clavier.nextInt();
        
        for (int i=1; i <= nombre1; i++) { 
            System.out.println(i); 
        } 
    }
    
}]]>				</paragraph>
				</popup>

      </act>

    </learningObject>
    
    <learningObject title="À vous de jouer...">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Il est temps de se lancer et d’écrire vos premiers modules et programmes Java correspondant. 
          Voici quelques conseils pour vous guider dans la résolution de tels problèmes :
          <list listStyle="unordered">
            <item>il convient d’abord de bien comprendre le problème posé ; assurez-vous qu’il est parfaitement spécifié ;</item>
            <item>déclarez ensuite les variables (et leur type) qui interviennent dans l’algorithme ; les noms des variables risquant de ne pas être suffisamment explicites ;</item>
            <item><formatted style="bold">mettez en évidence les variables « données », les variables « résultats » et les variables de travail ;</formatted></item>
            <item>n’hésitez pas à faire une ébauche de résolution en français avant d’élaborer l’algorithme définitif pseudo-codé.</item>
            <item>Écrivez la partie algorithmique <formatted style="bold">AVANT</formatted> de vous lancer dans la programmation en Java.</item>
          </list>
        </paragraph>
        
        <paragraph>
        Écrivez les algorithmes et codez les programmes Java correspondant qui 
          <list listStyle="ordered">
            <item>reçoit un naturel <formatted style="code">n</formatted> et affiche
              <list listStyle="ordered">
                <item>les <formatted style="code">n</formatted> premiers entiers strictement positifs ;</item>
                <item>les <formatted style="code">n</formatted> premiers entiers strictement positifs en ordre décroissant ;</item>
                <item>les <formatted style="code">n</formatted> premiers carrés parfaits ;</item>
                <item>les <formatted style="code">n</formatted> premiers naturels impairs ;</item>
                <item>les naturels impairs qui sont inférieurs ou égaux à <formatted style="code">n</formatted>.</item>
              </list>
              Si le <formatted style="code">n</formatted> reçu n'est pas strictement positif, votre programme s'arrêtera en générant une erreur/une exception.
            </item>
            <item>
              demande à l'utilisateur d'introduire un entier positif (non strictement). 
              Ce module permet à l'utilisateur de se tromper à plusieurs reprises mais l'utilisateur devra donner
              une bonne valeur pour arrêter le programme.
              (On suppose tout de même que l'utilisateur ne donne que des valeurs entières !) 
            </item>
            <item>
              <paragraph>
              lit une série de nombres entiers positifs, jusqu’à ce que l’utilisateur
              encode la valeur 0. Les nombres multiples de 3 seront affichés au fur et à mesure et le nombre
              de ces multiples sera affiché en fin de traitement.
              </paragraph>
              <paragraph>
              Pensez à utiliser le module écrit ci-dessus qui permet de lire un entier positif.
              </paragraph>
              </item>
            <item>
              retourne la somme des chiffres qui forment un nombre naturel <formatted style="code">n</formatted>
              Attention, on donne au départ le nombre et pas ses chiffres. Exemple : 133045 doit donner
              comme résultat 16, car 1 + 3 + 3 + 0 + 4 + 5 = 16.
            </item>
            <item>
              lit une suite de nombres positifs entrés au clavier et affiche
              le maximum, le minimum, leur somme et la moyenne. <newLine/>
              La fin de la suite de nombre sera signifiée par une valeur sentinelle que vous choisirez
              judicieusement.
            </item>
            <item>
              vérifie si un entier donné forme un palindrome ou non. Un nombre
              palindrome est un nombre qui lu dans un sens (de gauche à droite) est identique au nombre
              lu dans l’autre sens (de droite à gauche). Par exemple, 1047401 est un nombre palindrome.
            </item>
          </list>
        </paragraph>
        <paragraph>En java, n'oubliez pas d'écrire la javadoc et la méthode main pour tester vos méthodes.</paragraph>
        
        <paragraph title="Jeu de la fourchette">
          Écrivez un algorithme qui simule le jeu de la fourchette. Ce jeu consiste à essayer de découvrir
          un nombre quelconque compris entre 0 et 100 inclus, tiré au sort par l’ordinateur (la primitive
          <formatted style="code">hasard(n : entier)</formatted> retourne un entier entre 0 inclus et n exclus). 
          L’utilisateur a droit à huit essais maximum.
          À chaque essai, l’algorithme devra afficher un message indicatif « nombre donné trop petit »
          ou « nombre donné trop grand ». En conclusion, soit « bravo, vous avez trouvé en [nombre]
          essai(s) » soit « désolé, le nombre était [valeur] ».
        </paragraph>
        <paragraph>Écrivez le code java correspondant.</paragraph>
        <paragraph>
        Aide en Java : un petit tour dans l'API de la classe Random devrait vous aider à trouver l'équivalent du
        <formatted style="code">hasard(n : entier)</formatted> en Java
    </paragraph>
        
      </act>
    </learningObject>
  </unit>
</lesson>
