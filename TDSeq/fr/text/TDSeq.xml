<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="../../../_templates/java/latex.xsl"?>
<lesson xmlns="http://www.elml.ch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.elml.ch ../../../_config/validate.xsd" 
	label="TDSeq" title="TD Séquentiel - Rappels de base">
	
	<entry>
		<paragraph>
			Ce TD a pour but de 
			<paragraph>
			    <!--multimedia src="../image/**.jpeg" type="jpeg" /-->
        </paragraph>
		</paragraph>
	</entry>
	
	<!-- =========================================================== -->
	<unit label="Séquentiel" title="Algorithmes séquentiels">
	<!-- =========================================================== -->

    <entry>Revoyons ici les bases du pseudo-code et leur traduction en Java.</entry>
    
		<learningObject title="Le pseudo-code">
		<!-- ================================================ -->
		  <paragraph>
		    Le pseudo-code ou Langage de Description des Algorithmes (LDA en abrégé) est un langage
        formel et symbolique utilisant :
        <list listStyle="unordered">
			    <item>
            des noms symboliques destinés à représenter les objets sur lesquels s’effectuent des
            actions ;
          </item>
          <item>
            des opérateurs symboliques ou des mots-clés traduisant les opérations primitives
            exécutables par un exécutant donné ;
          </item>
          <item>
            des structures de contrôle types.
          </item>
        </list>
		  </paragraph>
		</learningObject>

	</unit>
		
	<!-- =================================================================== -->
	<unit label="VariablesEtTypes" title="Variables et types">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Nous savons que les opérations que l’ordinateur devra exécuter portent sur des éléments qui
        sont les <formatted style="bold">données</formatted> du problème.
      </paragraph>
      <paragraph>
        Lorsqu’on attribue un <formatted style="bold">nom</formatted> 
        et un <formatted style="bold">type</formatted> à ces données, on
        parle alors de <formatted style="bold">variables</formatted>. 
      </paragraph>
      <paragraph>
        Dans un algorithme, une variable conserve toujours son nom et
        son type, mais peut changer de <formatted style="bold">valeur</formatted>.
         <list listStyle="unordered">
			    <item>
            Le <formatted style="bold">nom</formatted> d’une variable permet de la caractériser et de la reconnaitre ;
          </item>
          <item>
            le <formatted style="bold">type</formatted> d’une variable décrit la nature de son contenu.
          </item>
        </list>
			</paragraph>
    </entry>
    
			<learningObject title="Les types autorisés en algo">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          Dans un premier temps, les seuls types utilisés sont :
          <list listStyle="unordered">
            <item><formatted style="code">entier</formatted> pour les nombres entiers ;</item>
            <item><formatted style="code">réel</formatted> pour les nombres réels ;</item>
            <item><formatted style="code">caractère</formatted> pour les différentes lettres et caractères
              (par exemple ceux qui apparaissent sur un clavier : ‘a’, ‘1’, ‘#’, etc.)</item>
            <item><formatted style="code">chaine</formatted> pour les variables contenant un ou plusieurs caractère(s) ou aucun (la chaine vide)
              (par exemple : "Bonjour", "Bonjour le monde", "a", "", etc.)</item>
            <item><formatted style="code">booléen</formatted> les variables de ce type 
            ne peuvent valoir que <formatted style="code">vrai</formatted> ou <formatted style="code">faux</formatted></item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Le type des données" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>une date du calendrier ? <gap answers="3 entiers,trois entiers,2 entiers 1 chaine,1 chaine 2 entiers">3 entiers</gap></item>  
									<item>un moment dans la journée ? <gap answers="3 entiers, trois entiers">3 entiers</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="1 réel,un réel, réel">1 réel</gap></item>  
									<item>votre nom ? <gap answers="une chaine,1 chaine, chaine">1 chaine</gap></item>  
									<item>vos initiales ?<gap answers="2 caractères,3 caractères">2 caractères</gap></item>  
									<item>votre adresse ? <gap answers="1 chaine">1 chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      
			<learningObject title="Les types équivalents en java">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          Les équivalents Java des types donnés en algo sont
          <list listStyle="unordered">
            <item><formatted style="code">int</formatted> pour le type <formatted style="code">entier</formatted> pour les nombres entiers ;</item>
            <item><formatted style="code">double</formatted> pour le type <formatted style="code">réel</formatted> pour les nombres réels ;</item>
            <item><formatted style="code">char</formatted> pour le type <formatted style="code">caractère</formatted> pour les différentes lettres et caractères</item>
            <item><formatted style="code">String</formatted> pour le type <formatted style="code">chaine</formatted> 
              pour les variables contenant un ou plusieurs caractère(s) ou aucun (la chaine vide)
            </item>
            <item><formatted style="code">boolean</formatted> pour le type <formatted style="code">booléen</formatted> les variables de ce type 
            ne peuvent valoir, en Java, que <formatted style="code">true</formatted> ou <formatted style="code">false</formatted></item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Les commandes de base" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>une date du calendrier ? <gap answers="3 entiers,trois entiers,2 entiers 1 chaine,1 chaine 2 entiers">3 entiers</gap></item>  
									<item>un moment dans la journée ? <gap answers="3 entiers, trois entiers">3 entiers</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="1 réel,un réel, réel">1 réel</gap></item>  
									<item>votre nom ? <gap answers="une chaine,1 chaine, chaine">1 chaine</gap></item>  
									<item>vos initiales ?<gap answers="2 caractères,3 caractères">2 caractères</gap></item>  
									<item>votre adresse ? <gap answers="1 chaine">1 chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      <learningObject title="Java est un langage fortement typé.">
			<!-- ================================================ -->
			  <clarify>
			  <paragraph>
			    Java est un langage fortement typé.
			  </paragraph>
        <paragraph>
          Toute donnée a un type. Quels types ?
          <list listStyle="unordered">
            <item><formatted style="code">primitifs prédéfinis : </formatted> entier, réel, booléen (logique) ;</item>
            <item><formatted style="code">références prédéfinis :</formatted> tableaux, String, . . . ;</item>
            <item><formatted style="code">références définis par le programmeur</formatted> </item>
          </list>
        </paragraph>
        
        <paragraph title="Les types primitifs" icon="important" />
        <paragraph>
			    <multimedia src="../image/primitifs.png" type="png" />
        </paragraph>
        
        <paragraph title="Les types primitifs numériques entiers" icon="important" />
        <paragraph>
          Les types primitifs numériques entiers sont
          <formatted style="code">byte</formatted>, <formatted style="code">short</formatted>, 
          <formatted style="code">int</formatted> et <formatted style="code">long</formatted> (<formatted style="code">char</formatted> sera vu à part),
          <list listStyle="unordered">
            <item> ce sont des nombres signés (en complément à 2)</item>
            <item> ils sont codés sur 
              <list listStyle="unordered">
                <item> 8 bits pour un <formatted style="code">byte</formatted> ;</item>
                <item> 16 bits pour un <formatted style="code">short</formatted> ;</item>
                <item> 32 bits pour un <formatted style="code">int</formatted> ;</item>
                <item> 64 bits pour un <formatted style="code">long</formatted> ;</item>
              </list>
            </item>
            <item> ils comprennent donc les valeurs :
              <list listStyle="unordered">
                <item> -128 à 127 pour un <formatted style="code">byte</formatted> ;</item>
                <item> -32768 à 32767 pour un <formatted style="code">short</formatted> ;</item>
                <item> -2147483648 à 2147483647 pour un <formatted style="code">int</formatted> ;</item>
                <item> -9223372036854775808 à 9223372036854775807 pour un <formatted style="code">long</formatted> ;</item>
              </list>
            </item>
          </list>
        </paragraph>
        
        <paragraph title="Les littéraux pour les types primitifs numériques entiers" icon="important" />
        <paragraph>
          Un <formatted style="bold">littéral</formatted>, c'est une notation pour représenter une valeur fixée directement dans un code  source.
        </paragraph>
        <paragraph>
          Un <formatted style="bold">littéral numérique décimal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres</item>
                <item>éventuellement séparés par<formatted style="input">_</formatted> pour la lisibilité</item>
                <item>suivi éventuellement du suffixe ( <formatted style="input">l</formatted> ou <formatted style="input">L</formatted>) 
                qui distingue un <formatted style="code">int</formatted> d’un <formatted style="code">long</formatted></item>
                <item>pas de <formatted style="code">byte</formatted> ou <formatted style="code">short</formatted>, 
                un littéral est <formatted style="code">int</formatted> (ou <formatted style="code">long</formatted>)</item>
              </list>
        </paragraph>
        
        <paragraph>
          Un <formatted style="bold">littéral numérique octal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres de 0 à 7</item>
                <item>précédé de 0.</item>
              </list>
        </paragraph>
        
        <paragraph>
          Un <formatted style="bold">littéral numérique hexadécimal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres et lettres a,b,c,d,e,f (minuscules/majuscules)</item>
                <item>précédé de 0x ou 0X</item>
            </list>
          </paragraph>
          
          <paragraph>
          Un <formatted style="bold">littéral numérique binaire</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres 0 et 1</item>
                <item>précédé de 0b ou 0B</item>
            </list>
          </paragraph>
          
          <paragraph>
          Par exemple, la quantité 100 de type <formatted style="code">int</formatted> peut s'écrire 
            <list listStyle="unordered">
                <item>100</item>
                <item>1_0_0</item>
                <item>0144</item>
                <item>01_44</item>
                <item>0x64</item>
                <item>0b110_0100</item>
              </list>
            </paragraph>
        </clarify>
        
        <clarify>
        <paragraph title="Le type numérique caractère" icon="important" />
        <paragraph>
          <formatted style="code">char</formatted> est
          <list listStyle="unordered">
            <item>un caractère Unicode codé en UTF16</item>
            <item>un entier non signé sur 16 bits</item>
            <item>assimilé à un entier </item>
          </list>
        </paragraph>
        <paragraph>
          Pour un littéral de type char : un caractère entre single quote.
          Par exemple : 'a', '1', ' ', ...
        </paragraph>
        <paragraph>
          Il existe des séquences d’échappement pour représenter certains caractères spéciaux :
          <list listStyle="unordered">
            <item><formatted style="code">\n</formatted> pour représenter un <formatted style="bold">saut de ligne</formatted></item>
            <item><formatted style="code">\t</formatted> pour représenter une <formatted style="bold">tabulation</formatted></item>
            <item><formatted style="code">\'</formatted> pour représenter le caractère <formatted style="bold">'</formatted></item>
            <item><formatted style="code">\"</formatted> pour représenter le caractère <formatted style="bold">"</formatted></item>
          </list>
        </paragraph>
      </clarify>
      
      <clarify>
        <paragraph title="Les types primitifs numériques flottants" icon="important" />
        <paragraph>
          Les types primitifs numériques flottants sont
          <formatted style="code">float</formatted> et <formatted style="code">double</formatted>.
          <list listStyle="unordered">
            <item>ils respectent la norme IEEE754 ;</item>
            <item> ils sont codés sur 
              <list listStyle="unordered">
                <item> 32 bits pour un <formatted style="code">float</formatted> ;</item>
                <item> 64 bits pour un <formatted style="code">double</formatted> ;</item>
              </list>
            </item>
            <item>on utilisera plus souvent le type <formatted style="code">double</formatted> ;</item>
            <item>il s'agit d'une <formatted style="bold">modélisation</formatted> de la notion mathématique.</item>
          </list>
        </paragraph>
        
        <paragraph title="Les littéraux pour les types primitifs numériques flottants" icon="important" />
        <paragraph>
          Un <formatted style="bold">littéral</formatted>, c'est une notation pour représenter une valeur fixée directement dans un code  source.
        </paragraph>
        <paragraph>
          Un <formatted style="bold">littéral numérique flottant se compose de parties optionnelles (mais pas ensemble)</formatted> :
            <list listStyle="ordered">
                <item>une partie entière</item>
                <item>.</item>
                <item>partie décimale</item>
                <item>E ou e</item>
                <item>exposant</item>
                <item>suffixe (en l’absence de suffixe : un double)</item>
              </list>
        </paragraph>
        <paragraph>
          Par exemple : 1.2E3, 1.F, .1, 1e−2d, 1f
        </paragraph>
        <paragraph>
          Par contre : 1, .E1, E1 ne sont pas des littéraux pour les types primitifs numériques flottants
        </paragraph>
      </clarify>
      
      <clarify>
        <paragraph title="Le type primitif booléen" icon="important" />
        <paragraph>
          <formatted style="code">boolean</formatted>
          <list listStyle="unordered">
            <item>aussi appelé logique ; </item>
            <item> il peut prendre 2 valeurs :
              <list listStyle="unordered">
                <item><formatted style="code">true</formatted> ;</item>
                <item><formatted style="code">false</formatted> ;</item>
              </list>
            </item>
            <item>il prend 1 octet en mémoire.</item>
          </list>
        </paragraph>
      </clarify>
      
      
        <paragraph title="Les types références prédéfinis : les chaines de caractères" icon="important" />
        <paragraph>
			    <formatted style="code">String</formatted>
			    <list listStyle="unordered">
            <item>il s'agit de caractères entre double quote : par exemple : "Java", "Bonjour tout le monde", "a",...  ; </item>
            <item>est un type référence prédéfini ;</item>
            <item> Attention <formatted style="code">char</formatted> ≠ <formatted style="code">String</formatted></item>
          </list>
        </paragraph>
        
      </learningObject>
      
      
			<learningObject title="Déclaration de variables en algo">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          La <formatted style="bold">déclaration</formatted> d’une variable est l’instruction qui définit son <formatted style="bold">nom</formatted> 
          et son <formatted style="bold">type</formatted>.
        </paragraph>
        <paragraph>
          <formatted style="input">num1, num2 : entiers</formatted>
        </paragraph>
        <paragraph>
          L’ensemble des instructions de la forme <formatted style="input">variable1, variable2,. . . : type</formatted>
          forme la partie d’un algorithme nommée <formatted style="bold">déclaration des variables</formatted>. 
        </paragraph>
        <paragraph>
          La déclaration des informations apparaitra toujours en <formatted style="bold">début</formatted> d’algorithme, ou dans un bloc annexe appelé
          dictionnaire des variables ou encore dictionnaire des données.
        </paragraph>
        
        <paragraph title="Valeur initiale ?" icon="important" />
        <paragraph>
          Attention, lors de la déclaration d’une variable, <formatted style="bold">celle-ci n’a pas de valeur</formatted> ! 
          Nous verrons que c’est l’instruction d’affectation qui va servir à donner un contenu aux variables déclarées.
        </paragraph>
        </clarify>
      
			  <clarify>
			  <paragraph title="Comment nommer correctement une variable ?" icon="icon_question" />
        <paragraph>
          Le but est de trouver un nom qui soit suffisamment <formatted style="bold">court</formatted>, 
          tout en restant <formatted style="bold">explicite</formatted> et ne prêtant <formatted style="bold">pas à confusion</formatted>.
        </paragraph>
        <paragraph>
          Ainsi <formatted style="italic">num1</formatted> est plus approprié pour désigner le premier numérateur 
          que <formatted style="italic">zozo1</formatted>, <formatted style="italic">tintin</formatted>, <formatted style="italic">bidule</formatted>
          ou <formatted style="italic">premierNumérateur</formatted>. 
          De même, ne pas appeler <formatted style="italic">den</formatted> la variable représentant le numérateur.
        </paragraph>
        <paragraph>
          Il faut aussi tenir compte que les langages de programmation imposent certaines limitations
          (parfois différentes d’un langage à l’autre) ce qui peut nécessiter une modification du nom
          lors de la traduction.
        </paragraph>
        <paragraph>
          Voici quelques règles et limitations traditionnelles dans les langages de programmation :
          <list listStyle="unordered">
            <item>
            Un nom de variable est généralement une suite de caractères alphanumériques d’un
            seul tenant (pas de caractères blancs) et ne commençant jamais par un chiffre. Ainsi
            x1 est correct mais pas 1x.
            </item>
            <item>
            Pour donner un nom composé à une variable, on peut utiliser le « tiret bas » ou underscore 
            (par ex. premier_numérateur) mais on déconseille d’utiliser le signe « – » qui est
            plutôt réservé à la soustraction. Ainsi, dans la plupart des langages, premier-numérateur
            serait interprété comme la soustraction des variables premier et numérateur.
            </item>
            <item>
            Une alternative à l’utilisation du tiret bas pour l’écriture de noms de variables composés
            est la notation « chameau » (camelCase en anglais), qui consiste à mettre une majuscule
            au début des mots (généralement à partir du deuxième), par exemple premierNombre
            ou dateNaissance.
            </item>
            <item>
            Les indices et exposants sont proscrits.
            </item>
            <item>
            Les mots-clés du langage sont interdits (par exemple for, if, while pour Java et Cobol)
            et on déconseille d’utiliser les mots-clés du pseudo-code (tels que Lire, Afficher, pour. . .)
            </item>
            <item>
            Certains langages n’autorisent pas les caractères accentués (tels que à, ç, ê, ø, etc.)
            ou les lettres des alphabets non latins mais d’autres oui ; certains font la
            distinction entre les minuscules et majuscules, d’autres non. En algorithmique, nous
            admettons, dans les noms de variables les caractères accentués du français, par ex. :
            durée, intérêts, etc.
            </item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Comment déclarer" shuffle="yes">
						<fillInBlanks>
							<question>
							  Quelle instruction permet de déclarer :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>le jour d'une date ?<gap answers="jour : entier">jours : entier</gap></item>  
									<item>l'heure d'un moment ? <gap answers="heure : entier">heure : entier</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="prix : réel">prix : réel</gap></item>  
									<item>votre nom ? <gap answers="nom : chaine">nom : chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
	
			<learningObject title="Déclaration de variables en Java">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          La <formatted style="bold">déclaration</formatted> d’une variable est l’instruction qui définit son <formatted style="bold">nom</formatted> 
          et son <formatted style="bold">type</formatted>.
        </paragraph>
        <paragraph>
          <formatted style="input">int num1;</formatted>
        </paragraph>
        <paragraph>
          L’ensemble des instructions de la forme <formatted style="input">type nom;</formatted>
          (où le <formatted style="code">type</formatted> peut être un type primitif, un type référence prédéfini ou un type référence défini par l'utilisateur) 
          forme la <formatted style="bold">déclaration des variables</formatted>. 
        </paragraph>
        <paragraph>
          La déclaration des informations apparaitra en <formatted style="bold">début</formatted> de bloc.
        </paragraph>
        
        <paragraph title="Valeur initiale ?" icon="important" />
        <paragraph>
          Attention, comme en algo, lors de la déclaration d’une variable, <formatted style="bold">celle-ci n’a pas de valeur</formatted> ! 
          Nous verrons que c’est l’instruction d’affectation qui va servir à donner un contenu aux variables déclarées.
        </paragraph>
        </clarify>
      
			  <clarify>
			  <paragraph title="Comment nommer correctement une variable ?" icon="icon_question" />
        <paragraph>
          Le but est de trouver un nom qui soit suffisamment <formatted style="bold">court</formatted>, 
          tout en restant <formatted style="bold">explicite</formatted> et ne prêtant <formatted style="bold">pas à confusion</formatted>.
        </paragraph>
        <paragraph>
          Il faut aussi tenir compte des limitations du langage.
          <list listStyle="unordered">
            <item>
            Un nom de variable est généralement une suite de caractères alphanumériques d’un
            seul tenant (pas de caractères blancs) et ne commençant jamais par un chiffre. Ainsi
            <formatted style="code">x1</formatted> est correct mais pas <formatted style="code">1x</formatted>.
            </item>
            <item>
            un nom de variable ne peut comporter que des lettres, des chiffres, les caractères <formatted style="code">_</formatted> et <formatted style="code">$</formatted>.
            </item>
            <item>
            L’écriture de noms de variables composés
            est la notation « chameau » (camelCase en anglais), qui consiste à mettre une majuscule
            au début des mots (généralement à partir du deuxième), par exemple <formatted style="code">premierNombre</formatted>
            ou <formatted style="code">dateNaissance</formatted>.
            </item>
            <item>
            Pour donner un nom composé à une variable entièrement en majuscules, on peut utiliser le « tiret bas » ou underscore 
            (par ex. <formatted style="code">PREMIER_NUMERATEUR</formatted>).
            </item>
            <item>
            Les mots-clés du langage sont interdits (par exemple <formatted style="code">for</formatted>, <formatted style="code">if</formatted>, <formatted style="code">while</formatted>)
            </item>
          </list>
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="Comment déclarer" shuffle="yes">
						<fillInBlanks>
							<question>
							  Quelle instruction permet de déclarer :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>le jour d'une date ?<gap answers="int jour;">int jour;</gap></item>  
									<item>l'heure d'un moment ? <gap answers="int heure;">int heure;</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="double prix;">double prix;</gap></item>  
									<item>votre nom ? <gap answers="String nom;">String nom;</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
	</unit>
	
	
	<!-- =================================================================== -->
	<unit label="OpérateursEtExpressions" title="Opérateurs et expressions">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Les <formatted style="bold">opérateurs</formatted> agissent sur les <formatted style="bold">variables</formatted> 
				et les <formatted style="bold">constantes</formatted> pour former des <formatted style="bold">expressions</formatted>. 
      </paragraph>
      <paragraph>
				Une expression est donc une combinaison cohérente de variables, de constantes et d’opérateurs,
				éventuellement accompagnés de parenthèses.
			</paragraph>
    </entry>
    
			<learningObject title="Les opérateurs arithmétiques élémentaires en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont les opérateurs binaires bien connus :
          <list listStyle="unordered">
            <item><formatted style="code">+</formatted> addition</item>
            <item><formatted style="code">-</formatted> soustraction</item>
            <item><formatted style="code">*</formatted> multiplication</item>
            <item><formatted style="code">/</formatted> division réelle</item>
          </list>
          Ils agissent sur des variables ou expressions à valeurs entières ou réelles. 
        </paragraph>
        <paragraph>
          Plusieurs opérateurs peuvent être utilisés pour former des expressions plus ou moins complexes, 
          en tenant compte des règles de calcul habituelles, notamment la priorité de la multiplication et de la division
          sur l’addition et la soustraction. 
        </paragraph>
        <paragraph>
          Il est aussi permis d’utiliser des parenthèses, par exemple <formatted style="input">a – (b + c * d)/x</formatted>. 
        </paragraph>
        <paragraph>
          Tout emploi de la division devra être accompagné d’une réflexion sur la
          valeur du dénominateur, une division par 0 entrainant toujours l’arrêt d’un algorithme.
        </paragraph>
        </clarify>
      </learningObject>
      
      
			<learningObject title="Les opérateurs arithmétiques élémentaires en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont les opérateurs binaires bien connus :
          <list listStyle="unordered">
            <item><formatted style="code">+</formatted> addition</item>
            <item><formatted style="code">-</formatted> soustraction</item>
            <item><formatted style="code">*</formatted> multiplication</item>
            <item><formatted style="code">/</formatted> division réelle si au moins un des deux opérandes est réel</item>
            <item><formatted style="code">/</formatted> division entière si les deux opérandes sont entiers</item>
          </list>
          Ils agissent sur des variables ou expressions à valeurs entières ou réelles. 
        </paragraph>
        <paragraph>
          Plusieurs opérateurs peuvent être utilisés pour former des expressions plus ou moins complexes, 
          en tenant compte des règles de calcul habituelles, notamment la priorité de la multiplication et de la division
          sur l’addition et la soustraction. 
        </paragraph>
        <paragraph>
          Il est aussi permis d’utiliser des parenthèses, par exemple <formatted style="input">a – (b + c * d)/x</formatted>. 
        </paragraph>
        <paragraph>
          Tout emploi de la division devra être accompagné d’une réflexion sur la
          valeur du dénominateur, une division par 0 entrainant un arrêt du programme.
        </paragraph>
        </clarify>
      </learningObject>
      
			<learningObject title="Les opérateurs DIV et MOD en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont deux opérateurs très importants qui ne peuvent s’utiliser qu’avec des variables entières :
          <list listStyle="unordered">
            <item><formatted style="code">DIV</formatted> division entière</item>
            <item><formatted style="code">MOD</formatted> reste de la division entière</item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
			<learningObject title="Les opérateurs DIV et MOD en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont deux opérateurs très importants qui ne peuvent s’utiliser qu’avec des variables entières :
          <list listStyle="unordered">
            <item><formatted style="code">/</formatted> division entière si les deux opérandes sont entiers</item>
            <item><formatted style="code">%</formatted> reste de la division entière</item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
      <learningObject title="Les fonctions mathématiques complexes en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          <list listStyle="unordered">
            <item>L’élévation à la puissance sera notée ** ou ˆ . </item>
            <item>Pour la racine carrée d’une variable x nous écrirons √x . Attention, pour ce dernier, de veiller à ne l’utiliser qu’avec un radicant positif !
            Exemple : <formatted style="code">(−b +√(b ∗ ∗2 − 4 ∗ a ∗ c))/(2 ∗ a)</formatted></item>
            <item> À votre avis, pourquoi ne pas avoir écrit « 4ac » et « 2a » ?</item>
            <item>Si nécessaire, on se permettra d’utiliser les autres fonctions mathématiques sous leur forme
            la plus courante dans la plupart des langages de programmation (exemples : sin(x), tan(x), log(x), exp(x). . .)</item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    
    <learningObject title="Les fonctions mathématiques complexes en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
        L'essentiel des fonctions mathématiques se trouvent dans la classe Math.
          <list listStyle="unordered">
            <item><formatted style="code">Math.pow(a,b)</formatted> est l'élévation à la puissance aˆb</item>
            <item><formatted style="code">Math.sqrt(x)</formatted> est la racine carrée d’une variable x, √x . Attention, pour ce dernier, de veiller à ne l’utiliser qu’avec un radicant positif, sinon, une exception sera générée !</item>
            <item>Si nécessaire, les autres fonctions mathématiques <formatted style="code">Math.sin(x)</formatted>, 
            <formatted style="code">Math.tan(x)</formatted>, <formatted style="code">Math.log(x)</formatted>, <formatted style="code">Math.exp(x)</formatted>. . .</item>
            <item>Toutes les informations se trouvent dans l'<link uri="http://docs.oracle.com/javase/8/docs/api/">API</link>, à la classe Math.</item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    </unit>
    
    
	<!-- =================================================================== -->
	<unit label="Affectation" title="L’affectation d’une valeur à une variable">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Cette opération est probablement l’opération la plus importante. En effet, une variable ne
        prend son sens réel que si elle reçoit à un moment donné une valeur. Il y a deux moyens de
        donner une valeur à une variable.
      </paragraph>
    </entry>
    
			<learningObject title="Affectation interne en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation interne</formatted> lorsque la valeur d’une variable est « calculée » par l’exécutant
          de l’algorithme lui-même à partir de données qu’il connait déjà :
          <formatted style="input">nomVariable ← expression</formatted>
          (une expression est une combinaison de variables et d’opérateurs). <formatted style="bold">L’expression a une valeur</formatted>.
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="" shuffle="yes">
					<multipleChoice>
						<question>Les exemples d’affectation sont-ils corrects ?
						</question>
						<answer feedback="" correct="yes">somme ← nombre1 + nombre2</answer>
						<answer feedback="" correct="yes">denRes ← den1 * den2</answer>
						<answer feedback="" correct="yes">cpt ← cpt + 1</answer>
						<answer feedback="" correct="yes">delta ← b**2 – 4*a*c</answer>
						<answer feedback="" correct="yes">maChaine ← "Bonjour"</answer>
						<answer feedback="" correct="yes">test ← a = b</answer>
						<answer feedback="" correct="no">somme + 1 ← 3</answer>
						<answer feedback="" correct="no">somme ← 3n</answer>
					</multipleChoice>
				</selfCheck>
				</act>
				<paragraph>
				Remarques
				<list listStyle="unordered">
            <item>
              Il est de règle que le résultat de l’expression à droite du signe d’affectation (←) soit de
              même type que la variable à sa gauche. On tolère certaines exceptions :
              <list listStyle="unordered">
                <item>
                  <formatted style="code">varEntière ← varRéelle</formatted> : dans ce cas le contenu de la variable sera la valeur tronquée de l’expression réelle. <newLine/>
                  Par exemple si « nb » est une variable de type entier,
                  son contenu après l’instruction <formatted style="input">nb ← 15/4 »</formatted> sera 3.
                </item>
                <item><formatted style="code">varRéelle ← varEntière</formatted> : ici, il n’y a pas de perte de valeur.</item>
                <item><formatted style="code">varChaine ← varCaractère</formatted> : équivalent à <formatted style="code">varChaine ← chaine(varCaractère)</formatted>.</item>
                <item>Le contraire n’est évidemment pas accepté.</item>
              </list>
            </item>
            <item>
            Seules les variables déclarées peuvent être affectées, que ce soit par l’affectation externe
            ou interne !
            </item>
            <item>
            Nous ne mélangerons pas la déclaration d’une variable et son affectation interne dans
            une même ligne de code, donc pas d’instructions hybrides du genre <formatted style="code">x ← 2 : entier</formatted> ou
            encore <formatted style="code">x : entier(0)</formatted>.
            </item>
            <item>
            Pour l’affectation interne, toutes les variables apparaissant dans l’expression doivent
            avoir été affectées préalablement. Le contraire provoquerait un arrêt de l’algorithme.
            </item>
          </list>
        </paragraph>
      </learningObject>
      
      <learningObject title="Affectation interne en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation interne</formatted> lorsque la valeur d’une variable est « calculée » par l’exécutant
          de l’algorithme lui-même à partir de données qu’il connait déjà :
          <formatted style="input">nomVariable = expression;</formatted>
          (une expression est une combinaison de variables et d’opérateurs). <formatted style="bold">L’expression a une valeur</formatted>.
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="" shuffle="yes">
					<multipleChoice>
						<question>Les exemples d’affectation sont-ils corrects ?
						</question>
						<answer feedback="" correct="yes">somme = nombre1 + nombre2;</answer>
						<answer feedback="" correct="yes">denRes = den1 * den2;</answer>
						<answer feedback="" correct="yes">cpt = cpt + 1;</answer>
						<answer feedback="" correct="yes">delta = b**2 – 4*a*c;</answer>
						<answer feedback="" correct="yes">maChaine = "Bonjour";</answer>
						<answer feedback="" correct="no">somme + 1 = 3;</answer>
						<answer feedback="" correct="no">somme = 3n;</answer>
					</multipleChoice>
				</selfCheck>
				</act>
      </learningObject>
      
			<learningObject title="Affectation externe en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation externe</formatted> lorsque la valeur à affecter à une variable
           est donnée par l’utilisateur qui la communique à l’exécutant quand celui-ci le lui demande : cette valeur est
          donc externe à la procédure (l’ordinateur ne peut la deviner lui-même !)
        </paragraph>
        <paragraph>
          L’affectation externe est donc la primitive qui permet de recevoir de l’utilisateur, au moment
          où l’algorithme se déroule, une ou plusieurs valeur(s) et de les affecter à des variables en
          mémoire. 
        </paragraph>
        <paragraph>
          Nous noterons :
          <formatted style="input">lire liste_de_variables_à_lire</formatted>
        </paragraph>
        <paragraph>
          Exemples <newLine/><newLine/>
          <formatted style="input">lire nombre1, nombre2</formatted><newLine/><newLine/>
          <formatted style="input">lire num1, den1, num2, den2</formatted>
        </paragraph>
        <paragraph>
          L’exécution de cette instruction provoque une pause dans le déroulement de l’algorithme ;
          l’exécutant demande alors à l’utilisateur les valeurs des variables à lire. Ces valeurs viennent
          donc de l’extérieur ; une fois introduites dans le système, elles sont affectées aux variables
          concernées et l’algorithme peut reprendre son cours. Les possibilités d’introduction de don-
          nées sont nombreuses : citons par exemple l’encodage de données au clavier, un clic de souris,
          le toucher d’un écran tactile, des données provenant d’un fichier, etc.
        </paragraph>
        </clarify>
        </learningObject>
        
        
			<learningObject title="Affectation externe en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation externe</formatted> lorsque la valeur à affecter à une variable
           est donnée par l’utilisateur qui la communique à l’exécutant quand celui-ci le lui demande : cette valeur est
          donc externe à la procédure (l’ordinateur ne peut la deviner lui-même !)
        </paragraph>
        <paragraph>
          L’affectation externe est donc la primitive qui permet de recevoir de l’utilisateur, au moment
          où l’algorithme se déroule, une ou plusieurs valeur(s) et de les affecter à des variables en
          mémoire. 
        </paragraph>
        <paragraph>
          Nous noterons :
          </paragraph>
          <paragraph cssClass="java">
 import java. util .Scanner;
// ...
Scanner clavier = new Scanner(System.in);
// ...
int nombre1 = clavier. nextInt ();
				</paragraph>
        <paragraph>
          Les différentes lectures possibles sont :
          <list listStyle="unordered">
            <item>pour un entier : clavier.nextInt();</item>
            <item>pour un réel : clavier.nextDouble();</item>
            <item>pour un booléen : clavier.nextBoolean();</item>
            <item>pour un mot : clavier.next()</item>
            <item>pour une ligne : clavier.nextLine();</item>
            <item>pour un caractère : clavier.next.charAt(0);</item>
          </list>
        </paragraph>
        </clarify>
        </learningObject>
        
        <learningObject title="Communication des résultats en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          L’instruction de communication des résultats consiste à donner à l’extérieur (donc à l’utilisateur) 
          la valeur d’un résultat calculé au cours de l’exécution de l’algorithme.
        </paragraph>
        <paragraph>
          Nous noterons :
          <formatted style="input">afficher expression ou liste de variables séparées par des virgules</formatted>
          qui signifie que la valeur d’une expression (ou celles des différentes variables mentionnées) 
          sera fournie à l’utilisateur (par exemple par un affichage à l’écran ou par impression sur
          listing via l’imprimante, etc.).
          </paragraph>
          <paragraph>
          Exemples <newLine/><newLine/>
          <formatted style="input">afficher nb1</formatted><newLine/><newLine/>
          <formatted style="input">afficher "Le premier nombre vaut ", nb1, " et le seconde nombre vaut ", nb2 </formatted>
        </paragraph>
          <paragraph>
          Remarques :
          <list listStyle="unordered">
            <item>
              Ce ne serait pas une erreur fondamentale de remplacer lire par recevoir ou afficher
              par écrire. Il n’y a évidemment pas de confusion possible à partir du moment où l’on
              sait qu’il s’agit de primitives d’échange entre l’extérieur et l’ordinateur exécutant la
              procédure, mais par principe, il est conseillé d’utiliser une syntaxe commune et limitée
              à un petit nombre de mots-clés.
            </item>
            <item>
              Comme pour l’affectation interne, on ne peut afficher que des expressions dont les
              variables qui la composent ont été affectées préalablement.
            </item>
          </list>
          </paragraph>
        </clarify>
        </learningObject>
        
        <learningObject title="Communication des résultats en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          L’affichage de la valeur d'une variable <formatted style="input">var</formatted>  est donnée par l'instruction
          </paragraph>
          <paragraph cssClass="java">
 System.out.println (var);
				</paragraph>
        <paragraph>
          Si nous voulons précéder l'affichage de la valeur d'une variable <formatted style="input">var</formatted>  par un message, 
          nous utiliserons l'instruction
        </paragraph>
        <paragraph cssClass="java">
 System.out.println ("La variable var vaut " + var);
				</paragraph>
        </clarify>
        </learningObject>
    </unit>
    
    
    <!-- =================================================================== -->
	<unit label="Commentaires" title="Documenter son code">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				On n’insistera jamais assez sur la nécessité de documenter un algorithme en y insérant 
        des commentaires judicieux, clairs et suffisants !
      </paragraph>
    </entry>
    
    
    <learningObject title="Documenter son algorithme">
    <!-- ============================================================ -->
    <clarify>
      <paragraph>
        Un commentaire est un texte placé dans l’algorithme et destiné à faciliter au maximum 
        la compréhension d’un algorithme par le lecteur (parfois une autre personne, 
        mais aussi souvent l’auteur qui se perd dans son propre texte lorsqu’il s’y replonge après une interruption). 
      </paragraph>
      <paragraph>
        Ces commentaires (introduits par « // ») seront bien entendu ignorés par l’exécutant de l’algorithme.
      </paragraph>
      <paragraph>
        Notez qu’un excès de commentaires peut être aussi nuisible qu’un trop-peu pour la 
        compréhension d’un algorithme. 
        Par exemple, un choix judicieux de noms de variables peut s’avérer bien plus efficace que des commentaires superflus.
      </paragraph>
      <paragraph>
        Nous prendrons l’habitude de commenter chaque module en précisant ce qu’il fait.
      </paragraph>
    </clarify>
    </learningObject>
    
    <learningObject title="Documenter son code Java">
    <!-- ============================================================ -->
    <clarify>
      <paragraph>Il existe plusieurs manières d’ajouter un commentaire</paragraph>
      <paragraph cssClass="java">
// Commentaire sur une ligne
</paragraph>
      <paragraph cssClass="java">
  /∗ Commentaire sur
  plusieurs lignes ∗/
</paragraph>
    </clarify>
    </learningObject>
  </unit>
  
	<!-- =================================================================== -->
	<unit label="Structure" title="Structure générale">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Voyons maintenant comment démarrer les algo et le code Java.
      </paragraph>
    </entry>
    
    <learningObject title="Structure générale d’un algorithme">
    <!-- ============================================================ -->
      <clarify>
        <paragraph>
          La traduction d’un algorithme en pseudo-code constituera le contenu d’un module. 
          Un module contient donc la solution algorithmique d’un problème donné (ou d’une de ses parties).
          Sa structure générale sera la suivante :
        </paragraph>
        <paragraph cssClass="code">
module nomDuModule()
    déclaration des variables et constantes utilisées dans le module
    lecture des données
    instructions utilisant les données lues
    communication des résultats
fin module
				</paragraph>
        <paragraph>
          Remarques :
          <list listStyle="unordered">
            <item>Le code d’un algorithme sera toujours compris entre la première ligne, 
            appelée « <formatted style="bold">entête</formatted> » qui commence par le mot « module » suivi du nom choisi pour l’algorithme,
            et la ligne finale « fin module ».
            </item> 
            <item>Le code compris entre l’entête et la ligne finale sera toujours légèrement décalé vers la droite, 
              c’est un premier exemple d’<formatted style="bold">indentation</formatted> indispensable pour la lisibilité d’un programme, 
              nous y reviendrons lors de l’étude des structures alternatives et répétitives.
            </item>
            <item>Comme pour les variables, le <formatted style="bold">nomDuModule</formatted> 
            devra être <formatted style="bold">approprié</formatted> au contenu ! 
            Par exemple, sommerNombres(), additionnerFractions() plutôt que goPartez() ! 
            </item>
            <item>Le rôle des <formatted style="bold">parenthèses</formatted> qui suivent le nom du module sera expliqué plus tard.</item>
            <item>Il va de soi que toutes les parties de cette structure générale ne seront pas toujours 
            nécessaires : certains algorithmes ne nécessiteront pas de lecture de données, d’autres 
            ne devront pas communiquer des résultats...
            </item>
            <item>Pour la <formatted style="bold">lisibilité</formatted>, 
            on veillera toujours à ce qu’un module tienne sur une vingtaine de 
            lignes (donc, en pratique, sur un écran de 40 x 80 caractères ou une page). Ceci implique 
            que si le module devait être plus long, il faudrait le découper, comme nous le verrons 
            plus loin.
            </item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    
    <learningObject title="Structure générale d’un programme Java">
    <!-- ============================================================ -->
      <clarify>
        <paragraph>
          Tout programme Java s'écrit dans une <formatted style="bold">classe</formatted>. 
          <list listStyle="unordered">
            <item>Cette classe doit porter le même nom que le fichier ;</item>
            <item>elle commence par une majuscule ; </item>
            <item>elle doit avoir un nom explicite.</item>
          </list>
        </paragraph>
        <paragraph>
          <formatted style="input">$cat NomClasse.java</formatted>
        </paragraph>
        <paragraph cssClass="java">
public class NomClasse {
    // insert code here
}
        </paragraph>
        <paragraph title="Attention à la casse" icon="important" />
        <paragraph>
          Attention Java est sensible à la casse, il différencie majuscules et minuscules.
        </paragraph>
      </clarify>
      <clarify>
        <paragraph>
          Quand un programme Java s'exécute, il démarre à la méthode principale.
          <formatted style="bold">Méthode</formatted> est le mot Java équivalent de module en algo.
        </paragraph>
        <paragraph>
          La méthode principale s'appelle <formatted style="input">public static void main(String [] args) </formatted> et s'insère dans la classe de la façon suivante :
        </paragraph>
        <paragraph cssClass="java">
public class NomClasse {
    public static void main(String [] args) {
        // insert code here
    }
}
        </paragraph>
        <paragraph>
          On peut aussi y ajouter une lecture au clavier par exemple :
        </paragraph>
        <paragraph cssClass="java">
import java.util.Scanner;
public class NomClasse {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb = clavier.nextInt();
        System.out.println("Le nombre lu vaut" + nb);
    }
}
        </paragraph>
      </clarify>
    </learningObject>
  </unit>
  
  <!-- =================================================================== -->
	<unit label="CompilerExécuter" title="Compiler et exécuter un programme Java">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Nous avons vu maintenant comment écrire un programme en Java. Il faut maintenant voir comment le "lancer".
      </paragraph>
    </entry>
    
    <learningObject title="Java est un langage compilé puis interprété">
    <!-- ============================================================ -->
      <clarify>
        <paragraph>
			    <multimedia src="../image/java-jvm-jvm.png" type="png" />
        </paragraph>
        
        <paragraph>
          Prenons un exemple (fichier<formatted style="code"> Hello . java</formatted>)
          </paragraph>
          
        <paragraph cssClass="java">
// Mon premier programme
public class Hello {
    public static void main(String [] args) {
        System.out. println ("Bonjour !");
    }
}
        </paragraph>
        <paragraph>
        <list listStyle="unordered">
            <item>Compilons-le <formatted style="input">javac Hello.java</formatted></item>
            <item>On obtient la version compilée, le bytecode (<formatted style="code">Hello . class</formatted> )</item>
            <item>On peut l’exécuter <formatted style="input">java Hello</formatted></item>
            <item>On voit alors apparaitre à l'écran <formatted style="code">Bonjour !</formatted></item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
  </unit>
  
  
	<!-- =================================================================== -->
	<unit label="Exercices" title="Exercices">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Maintenant, mettons tout ça en pratique.
      </paragraph>
    </entry>
    
    <learningObject title="Compréhension d’algorithme">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des algorithmes donnés. 
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher si à chaque fois les deux nombres lus au départ sont successivement 2 et 3 ?
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="code">
module exerciceA()
  lire a, b
  b ← b+2*a
  afficher b
fin module
				</paragraph>
				            <gap answers="7">7</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
module exerciceB()
  a,b : entiers
  lire a, b
  a ← a+2*b
  afficher a
fin module
				</paragraph>
				            <gap answers="8">8</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
module exerciceC()
  a,b : entiers
  lire b, a
  b ← b+2*a
  afficher b
fin module
				</paragraph>
				            <gap answers="8">8</gap> 
									</item>
									<item>
										<paragraph cssClass="code">
module exerciceD()
  a,b : entiers
  quotient : réel
  lire b, a
  quotient ← a / b
  afficher quotient
fin module
				</paragraph>
				            <gap answers="1.5">1.5</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
module exerciceE()
  a, b, c, d : entiers
  lire c, d
  a ← 2*c+5*d
  b ← 2+c*3+d
  c ← a MOD b
  afficher a DIV c
fin module
				</paragraph>
				            <gap answers="2">2</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
module exerciceF()
  x, y : réels
  lire x, y
  x ← x*x 
  x ← x*x+y*y 
  x ← √x
  afficher x
fin module
				</paragraph>
				            <gap answers="5">5</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
module exerciceG()
  x, y : réels
  lire x, x
  x ← x MOD x + (x + 1) DIV 2
  afficher x + 3
fin module
				</paragraph>
				            <gap answers="5">5</gap> 
									</item>  
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
        </paragraph>
      </act>
    </learningObject>
      
    <learningObject title="Compréhension de codes Java">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des codes Java donnés. 
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher si à chaque fois les deux nombres lus au départ sont successivement 2 et 3 ?
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice1 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(nb1 + " " + nb2);
    }
}
        </paragraph>
				            <gap answers="2 3">2 3</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice2 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        int nb3 = 2*nb1 + nb2;
        System.out.println(nb3);
    }
}
        </paragraph>
				            <gap answers="7">7</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice3 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb2 = clavier.nextInt();
        int nb1 = clavier.nextInt();
        int nb3 = 2*nb1 + nb2;
        System.out.println(nb3);
    }
}
        </paragraph>
				            <gap answers="8">8</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice4 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(2*nb1 + nb2);
    }
}
        </paragraph>
				            <gap answers="7">7</gap> 
									</item>  
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice5 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(nb2/nb1);
    }
}
        </paragraph>
				            <gap answers="1">1</gap> 
									</item> 
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice6 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(nb1%nb2);
    }
}
        </paragraph>
				            <gap answers="2">2</gap> 
									</item> 
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice7 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        nb1 = clavier.nextInt();
        nb1 = nb1 * nb1;
        System.out.println(Math.sqrt(nb1));
    }
}
        </paragraph>
				            <gap answers="3">3</gap> 
									</item>  
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
        </paragraph>
      </act>
    </learningObject>
    
    <learningObject title="À vous de jouer...">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Il est temps de se lancer et d’écrire vos premiers modules et programmes Java correspondant. 
          Voici quelques conseils pour vous guider dans la résolution de tels problèmes :
          <list listStyle="unordered">
            <item>il convient d’abord de bien comprendre le problème posé ; assurez-vous qu’il est parfaitement spécifié ;</item>
            <item>déclarez ensuite les variables (et leur type) qui interviennent dans l’algorithme ; les noms des variables risquant de ne pas être suffisamment explicites ;</item>
            <item>mettez en évidence les variables « données », les variables « résultats » et les variables de travail ;</item>
            <item>n’hésitez pas à faire une ébauche de résolution en français avant d’élaborer l’algorithme définitif pseudo-codé.</item>
            <item>Écrivez la partie algorithmique <formatted style="bold">AVANT</formatted> de vous lancer dans la programmation en Java.</item>
          </list>
        </paragraph>
        
        <paragraph>
        Écrivez les algorithmes et codez les programmes Java correspondant qui 
          <list listStyle="ordered">
            <item>calcule et affiche la surface d’un carré en lisant la valeur de son côté au clavier.</item>
            <item>calcule et affiche la surface d’un rectangle  en lisant les valeurs de sa longueur et sa largeur.</item>
            <item>calcule et affiche la surface d’un cercle en lisant la valeur de son rayon au clavier.  (Pensez à aller voir la classe Math pour obtenir la valeur de PI ;))</item>
            <item>étant donné le prix unitaire d’un produit (hors TVA), le taux de TVA (en %) 
            et la quantité de produit vendue à un client, calcule et affiche le prix total à payer par ce client.</item>
            <item>réalise la permutation du contenu de deux variables.</item>
            <item>calcule la somme des chiffres d’un nombre entier de 3 chiffres. Réflexion : l’algorithme est-il aussi valide pour les entiers inférieurs à 100 ?</item>
            <item>étant donné un moment dans la journée donné par trois nombres lus, à savoir, heure, minute et seconde, calcule le nombre de secondes écoulées depuis minuit.</item>
            <item>étant donné un temps écoulé dans la journée exprimé en secondes, calcule et affiche ce temps sous la forme de trois nombres (heure, minute et seconde). <newLine/>
            Ex : 10000 secondes donnera 2h 46’40”</item>
          </list>
        </paragraph>
      </act>
    </learningObject>
  </unit>
	
	<!--metadata>
		<organisation level="1ère année" module="Laboratoires Java">
			<creationPosition><posNumber>1</posNumber></creationPosition>
		</organisation>
		<prerequisites><preReqItem label="none"/></prerequisites>
		<keywords><keywordItem>Java</keywordItem><keywordItem>Linux</keywordItem></keywords>
		<technical>
			<technicalRequirement>
				<type>Browser</type>
				<name>any</name>
				<minimumVersion>unknown</minimumVersion>
			</technicalRequirement>
		</technical>
		<lessonInfo>
			<language language="fr" derived="no"/>
			<lifecycle>
				<version>2013 - 2014</version>
				<contribute>
<person name="BEJ" />  <person name="CLG" />  <person name="CLR" />  <person name="DNA" />  <person name="MCD" />  <person name="NPX" />  <person name="PBT" />  <person name="SRV" /> 
				</contribute>
			</lifecycle>
			<educational><typicalLearningTime><time/></typicalLearningTime></educational>
		</lessonInfo>
		<rights>
			<cost>no</cost>
			<copyright>Distribué sous licence Creative Commons Paternité - Partage à l'Identique 2.0 Belgique</copyright>
			<copyrightURL>http://creativecommons.org/licenses/by-sa/2.0/be/</copyrightURL>
		</rights>
	</metadata-->

</lesson>
