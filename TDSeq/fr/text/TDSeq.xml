<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="../../../_templates/java/latex.xsl"?>
<lesson xmlns="http://www.elml.ch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.elml.ch ../../../_config/validate.xsd" 
	label="TDSeq" title="TD Séquentiel - Rappels de base">
	
	<entry>
		<paragraph>
			Ce TD a pour but de fixer les bases du LDA et de la programmation Java.
		</paragraph>
	</entry>
	
	<!-- =========================================================== -->
	<unit label="Sequentiel" title="Algorithmes séquentiels">
	<!-- =========================================================== -->

    <entry>Revoyons ici les bases du pseudo-code et leur traduction en Java.</entry>
    
		<learningObject title="Le pseudo-code">
		<!-- ================================================ -->
		  <paragraph>
		    Le pseudo-code ou Langage de Description des Algorithmes (LDA en abrégé) est un langage
        formel et symbolique utilisant :
        <list listStyle="unordered">
			    <item>
            des noms symboliques destinés à représenter les objets sur lesquels s’effectuent des
            actions ;
          </item>
          <item>
            des opérateurs symboliques ou des mots-clés traduisant les opérations primitives
            exécutables par un exécutant donné ;
          </item>
          <item>
            des structures de contrôle types.
          </item>
        </list>
		  </paragraph>
		</learningObject>

	</unit>
		
	<!-- =================================================================== -->
	<unit label="VariablesEtTypes" title="Variables et types">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Nous savons que les opérations que l’ordinateur devra exécuter portent sur des éléments qui
        sont les <formatted style="bold">données</formatted> du problème.
      </paragraph>
      <paragraph>
        Lorsqu’on attribue un <formatted style="bold">nom</formatted> 
        et un <formatted style="bold">type</formatted> à ces données, on
        parle alors de <formatted style="bold">variables</formatted>. 
      </paragraph>
      <paragraph>
        Dans un algorithme, une variable conserve toujours son nom et
        son type, mais peut changer de <formatted style="bold">valeur</formatted>.
         <list listStyle="unordered">
			    <item>
            Le <formatted style="bold">nom</formatted> d’une variable permet de la caractériser et de la reconnaitre ;
          </item>
          <item>
            le <formatted style="bold">type</formatted> d’une variable décrit la nature de son contenu.
          </item>
        </list>
			</paragraph>
    </entry>
    
			<learningObject title="Les types autorisés en algo">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          Dans un premier temps, les seuls types utilisés sont :
          <list listStyle="unordered">
            <item><formatted style="code">entier</formatted> pour les nombres entiers ;</item>
            <item><formatted style="code">réel</formatted> pour les nombres réels ;</item>
            <item><formatted style="code">chaine</formatted> pour les variables contenant un ou plusieurs caractère(s) ou aucun (la chaine vide)
              (par exemple : "Bonjour", "Bonjour le monde", "a", "", "1", etc.)</item>
            <item><formatted style="code">booléen</formatted> les variables de ce type 
            ne peuvent valoir que <formatted style="code">vrai</formatted> ou <formatted style="code">faux</formatted></item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Le type des données" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous et quel nombre de variables avez-vous besoin pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>un prix hors tva ?<gap answers="1 réel,un réel, réel">1 réel</gap></item>  
									<item>votre nom de famille (en supposant que vous n'ayez pas un nom composé) ? <gap answers="une chaine,1 chaine, chaine">1 chaine</gap></item>  
									<item>vos initiales ?<gap answers="2 chaines,3 chaines">2 chaines</gap></item>  
									<item>la longueur d'un rectangle ? <gap answers="1 réel, réel">1 réel</gap></item>  
									<item>une date du calendrier (au format 8/2/2017 par exemple) ? <gap answers="3 entiers,trois entiers">3 entiers</gap></item>  
									<item>un moment dans la journée ? <gap answers="3 entiers, trois entiers">3 entiers</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      
			<learningObject title="Les types équivalents en java">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          Les équivalents Java des types donnés en algo sont
          <list listStyle="unordered">
            <item><formatted style="code">int</formatted> pour le type <formatted style="code">entier</formatted> pour les nombres entiers ;</item>
            <item><formatted style="code">double</formatted> pour le type <formatted style="code">réel</formatted> pour les nombres réels ;</item>
            <item><formatted style="code">char</formatted> pour le type <formatted style="code">caractère</formatted> pour les différentes lettres et caractères</item>
            <item><formatted style="code">String</formatted> pour le type <formatted style="code">chaine</formatted> 
              pour les variables contenant un ou plusieurs caractère(s) ou aucun (la chaine vide)
            </item>
            <item><formatted style="code">boolean</formatted> pour le type <formatted style="code">booléen</formatted> les variables de ce type 
            ne peuvent valoir, en Java, que <formatted style="code">true</formatted> ou <formatted style="code">false</formatted></item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Les commandes de base" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>un prix hors tva ?<gap answers="double">double</gap></item>  
									<item>votre nom ? <gap answers="String">String</gap></item>  
									<item>une de vos initiales ?<gap answers="char">char</gap></item>  
									<item>la longueur d'un rectangle ? <gap answers="double">double</gap></item>  
									<item>le jour d'une date du calendrier ? <gap answers="int">int</gap></item>  
									<item>les heures d'un moment dans la journée ? <gap answers="int">int</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      <learningObject title="Java est un langage fortement typé.">
			<!-- ================================================ -->
			  <clarify>
			  <paragraph>
			    Java est un langage fortement typé.
			  </paragraph>
        <paragraph>
          Toute donnée a un type. Quels types ?
          <list listStyle="unordered">
            <item><formatted style="code">primitifs prédéfinis : </formatted> entier, réel, booléen (logique) ;</item>
            <item><formatted style="code">références prédéfinis :</formatted> tableaux, String, . . . ;</item>
            <item><formatted style="code">références définis par le programmeur</formatted> </item>
          </list>
        </paragraph>
        
        <paragraph title="Les types primitifs" icon="important" />
        <paragraph>
			    <multimedia src="../image/primitifs.png" type="png" />
        </paragraph>
        
        <paragraph title="Les types primitifs numériques entiers" icon="important" />
        <paragraph>
          Les types primitifs numériques entiers sont
          <formatted style="code">byte</formatted>, <formatted style="code">short</formatted>, 
          <formatted style="code">int</formatted> et <formatted style="code">long</formatted> (<formatted style="code">char</formatted> sera vu à part),
          <list listStyle="unordered">
            <item> ce sont des nombres signés (en complément à 2)</item>
            <item> ils sont codés sur 
              <list listStyle="unordered">
                <item> 8 bits pour un <formatted style="code">byte</formatted> ;</item>
                <item> 16 bits pour un <formatted style="code">short</formatted> ;</item>
                <item> 32 bits pour un <formatted style="code">int</formatted> ;</item>
                <item> 64 bits pour un <formatted style="code">long</formatted> ;</item>
              </list>
            </item>
            <item> ils comprennent donc les valeurs :
              <list listStyle="unordered">
                <item> -128 à 127 pour un <formatted style="code">byte</formatted> ;</item>
                <item> -32768 à 32767 pour un <formatted style="code">short</formatted> ;</item>
                <item> -2147483648 à 2147483647 pour un <formatted style="code">int</formatted> ;</item>
                <item> -9223372036854775808 à 9223372036854775807 pour un <formatted style="code">long</formatted> ;</item>
              </list>
            </item>
          </list>
        </paragraph>
        
        <paragraph title="Les littéraux pour les types primitifs numériques entiers" icon="important" />
        <paragraph>
          Un <formatted style="bold">littéral</formatted>, c'est une notation pour représenter une valeur fixée directement dans un code  source.
        </paragraph>
        <paragraph>
          Un <formatted style="bold">littéral numérique décimal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres</item>
                <item>éventuellement séparés par<formatted style="input">_</formatted> pour la lisibilité</item>
                <item>suivi éventuellement du suffixe ( <formatted style="input">l</formatted> ou <formatted style="input">L</formatted>) 
                qui distingue un <formatted style="code">int</formatted> d’un <formatted style="code">long</formatted></item>
                <item>pas de <formatted style="code">byte</formatted> ou <formatted style="code">short</formatted>, 
                un littéral est <formatted style="code">int</formatted> (ou <formatted style="code">long</formatted>)</item>
              </list>
        </paragraph>
        
        <paragraph>
          Un <formatted style="bold">littéral numérique octal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres de 0 à 7</item>
                <item>précédé de 0.</item>
              </list>
        </paragraph>
        
        <paragraph>
          Un <formatted style="bold">littéral numérique hexadécimal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres et lettres a,b,c,d,e,f (minuscules/majuscules)</item>
                <item>précédé de 0x ou 0X</item>
            </list>
          </paragraph>
          
          <paragraph>
          Un <formatted style="bold">littéral numérique binaire</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres 0 et 1</item>
                <item>précédé de 0b ou 0B</item>
            </list>
          </paragraph>
          
          <paragraph>
          Par exemple, la quantité 100 de type <formatted style="code">int</formatted> peut s'écrire 
            <list listStyle="unordered">
                <item>100</item>
                <item>1_0_0</item>
                <item>0144</item>
                <item>01_44</item>
                <item>0x64</item>
                <item>0b110_0100</item>
              </list>
            </paragraph>
        </clarify>
        
        <clarify>
        <paragraph title="Le type numérique caractère" icon="important" />
        <paragraph>
          <formatted style="code">char</formatted> est
          <list listStyle="unordered">
            <item>un caractère Unicode codé en UTF16</item>
            <item>un entier non signé sur 16 bits</item>
            <item>assimilé à un entier </item>
          </list>
        </paragraph>
        <paragraph>
          Pour un littéral de type char : un caractère entre single quote.
          Par exemple : 'a', '1', ' ', ...
        </paragraph>
        <paragraph>
          Il existe des séquences d’échappement pour représenter certains caractères spéciaux :
          <list listStyle="unordered">
            <item><formatted style="code">\n</formatted> pour représenter un <formatted style="bold">saut de ligne</formatted></item>
            <item><formatted style="code">\t</formatted> pour représenter une <formatted style="bold">tabulation</formatted></item>
            <item><formatted style="code">\'</formatted> pour représenter le caractère <formatted style="bold">'</formatted></item>
            <item><formatted style="code">\"</formatted> pour représenter le caractère <formatted style="bold">"</formatted></item>
          </list>
        </paragraph>
      </clarify>
      
      <clarify>
        <paragraph title="Les types primitifs numériques flottants" icon="important" />
        <paragraph>
          Les types primitifs numériques flottants sont
          <formatted style="code">float</formatted> et <formatted style="code">double</formatted>.
          <list listStyle="unordered">
            <item>ils respectent la norme IEEE754 ;</item>
            <item> ils sont codés sur 
              <list listStyle="unordered">
                <item> 32 bits pour un <formatted style="code">float</formatted> ;</item>
                <item> 64 bits pour un <formatted style="code">double</formatted> ;</item>
              </list>
            </item>
            <item>on utilisera plus souvent le type <formatted style="code">double</formatted> ;</item>
            <item>il s'agit d'une <formatted style="bold">modélisation</formatted> de la notion mathématique.</item>
          </list>
        </paragraph>
        
        <paragraph title="Les littéraux pour les types primitifs numériques flottants" icon="important" />
        <paragraph>
          Un <formatted style="bold">littéral</formatted>, c'est une notation pour représenter une valeur fixée directement dans un code  source.
        </paragraph>
        <paragraph>
          Un <formatted style="bold">littéral numérique flottant se compose de parties optionnelles (mais pas ensemble)</formatted> :
            <list listStyle="ordered">
                <item>une partie entière</item>
                <item>.</item>
                <item>partie décimale</item>
                <item>E ou e</item>
                <item>exposant</item>
                <item>suffixe (en l’absence de suffixe : un double)</item>
              </list>
        </paragraph>
        <paragraph>
          Par exemple : 1.2E3, 1.F, .1, 1e−2d, 1f
        </paragraph>
        <paragraph>
          Par contre : 1, .E1, E1 ne sont pas des littéraux pour les types primitifs numériques flottants
        </paragraph>
      </clarify>
      
      <clarify>
        <paragraph title="Le type primitif booléen" icon="important" />
        <paragraph>
          <formatted style="code">boolean</formatted>
          <list listStyle="unordered">
            <item>aussi appelé logique ; </item>
            <item> il peut prendre 2 valeurs :
              <list listStyle="unordered">
                <item><formatted style="code">true</formatted> ;</item>
                <item><formatted style="code">false</formatted> ;</item>
              </list>
            </item>
            <item>il prend 1 octet en mémoire.</item>
          </list>
        </paragraph>
        
        <paragraph title="Les types références prédéfinis : les chaines de caractères" icon="important" />
        <paragraph>
			    <formatted style="code">String</formatted>
			    <list listStyle="unordered">
            <item>il s'agit de caractères entre double quote : par exemple : "Java", "Bonjour tout le monde", "a",...  ; </item>
            <item>est un type référence prédéfini ;</item>
            <item> Attention <formatted style="code">char</formatted> ≠ <formatted style="code">String</formatted></item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
      
			<learningObject title="Déclaration de variables en algo">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          La <formatted style="bold">déclaration</formatted> d’une variable est l’instruction qui définit son <formatted style="bold">nom</formatted> 
          et son <formatted style="bold">type</formatted>.
        </paragraph>
        <paragraph>
          <formatted style="input">num1, num2 : entiers</formatted>
        </paragraph>
        <paragraph>
          L’ensemble des instructions de la forme <formatted style="input">variable1, variable2,. . . : type</formatted>
          forme la partie d’un algorithme nommée <formatted style="bold">déclaration des variables</formatted>. 
        </paragraph>
        <paragraph>
          La déclaration des informations apparaitra toujours en <formatted style="bold">début</formatted> d’algorithme.
        </paragraph>
        
        <paragraph title="Valeur initiale ?" icon="important" />
        <paragraph>
          Attention, lors de la déclaration d’une variable, <formatted style="bold">celle-ci n’a pas de valeur</formatted> ! 
          Nous verrons que c’est l’instruction d’affectation qui va servir à donner un contenu aux variables déclarées.
        </paragraph>
        </clarify>
      
			  <clarify>
			  <paragraph title="Comment nommer correctement une variable ?" icon="icon_question" />
        <paragraph>
          Le but est de trouver un nom qui soit suffisamment <formatted style="bold">court</formatted>, 
          tout en restant <formatted style="bold">explicite</formatted> et ne prêtant <formatted style="bold">pas à confusion</formatted>.
        </paragraph>
        <paragraph>
          Ainsi <formatted style="italic">num1</formatted> est plus approprié pour désigner le premier numérateur 
          que <formatted style="italic">zozo1</formatted>, <formatted style="italic">tintin</formatted>, <formatted style="italic">bidule</formatted>
          ou <formatted style="italic">premierNumérateur</formatted>. 
          De même, ne pas appeler <formatted style="italic">den</formatted> la variable représentant le numérateur.
        </paragraph>
        <paragraph>
          Il faut aussi tenir compte que les langages de programmation imposent certaines limitations
          (parfois différentes d’un langage à l’autre) ce qui peut nécessiter une modification du nom
          lors de la traduction.
        </paragraph>
        <paragraph>
          Voici quelques règles et limitations traditionnelles dans les langages de programmation :
          <list listStyle="unordered">
            <item>
            Un nom de variable est généralement une suite de caractères alphanumériques d’un
            seul tenant (pas de caractères blancs) et ne commençant jamais par un chiffre. Ainsi
            x1 est correct mais pas 1x.
            </item>
            <item>
            Pour donner un nom composé à une variable, on utilise 
            la notation « chameau » (camelCase en anglais), qui consiste à mettre une majuscule
            au début des mots (généralement à partir du deuxième), par exemple premierNombre
            ou dateNaissance.
            </item>
            <item>
            Pour donner un nom composé à une constante, on utilise le « tiret bas » ou underscore 
            (par ex. TAUX_TVA) 
            </item>
            <item>
            On déconseille d’utiliser le signe « – » qui est
            plutôt réservé à la soustraction. Ainsi, dans la plupart des langages, premier-numérateur
            serait interprété comme la soustraction des variables premier et numérateur.
            </item>
            <item>
            Les indices et exposants sont proscrits.
            </item>
            <item>
            Les mots-clés du langage sont interdits (par exemple for, if, while pour Java et Cobol)
            et on déconseille d’utiliser les mots-clés du pseudo-code (tels que Demander, Afficher, pour. . .)
            </item>
            <item>
            Certains langages n’autorisent pas les caractères accentués (tels que à, ç, ê, ø, etc.)
            ou les lettres des alphabets non latins mais d’autres oui ; certains font la
            distinction entre les minuscules et majuscules, d’autres non. En algorithmique, nous
            admettons, dans les noms de variables les caractères accentués du français, par ex. :
            durée, intérêts, etc.
            </item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Comment déclarer" shuffle="yes">
						<fillInBlanks>
							<question>
							  Quelle instruction permet de déclarer :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>le jour d'une date ?<gap answers="jour : entier">jour : entier</gap></item>  
									<item>l'heure d'un moment ? <gap answers="heure : entier">heure : entier</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="prix : réel">prix : réel</gap></item>  
									<item>votre nom ? <gap answers="nom : chaine">nom : chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
				
				<clarify>
				<paragraph title="Constante">
				  Une constante est une information pour laquelle nom, type et valeur sont figés.
          La liste des constantes utilisées dans un algorithme apparaitra dans la section déclaration des variables sous la forme suivante : 
        </paragraph>
        <paragraph>
          <formatted style="input">constante PI = 3,14</formatted>  
        </paragraph>
        <paragraph>
          <formatted style="input">constante ESI = "École Supérieure d’Informatique"</formatted>
        </paragraph>
        <paragraph>
          Il est inutile de spécifier leur type, celui-ci étant défini implicitement par la valeur de la constante.
        </paragraph>
        <paragraph>
          Le nom des constantes s'écrit en majuscules.
        </paragraph>
				</clarify>
      </learningObject>
	
			<learningObject title="Déclaration de variables en Java">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          La <formatted style="bold">déclaration</formatted> d’une variable est l’instruction qui définit son <formatted style="bold">nom</formatted> 
          et son <formatted style="bold">type</formatted>.
        </paragraph>
        <paragraph>
          <formatted style="input">int num1;</formatted>
        </paragraph>
        <paragraph>
          L’ensemble des instructions de la forme <formatted style="input">type nom;</formatted>
          (où le <formatted style="code">type</formatted> peut être un type primitif, un type référence prédéfini ou un type référence défini par l'utilisateur) 
          forme la <formatted style="bold">déclaration des variables</formatted>. 
        </paragraph>
        <paragraph>
          La déclaration des informations apparaitra en <formatted style="bold">début</formatted> de bloc.
        </paragraph>
        
        <paragraph title="Valeur initiale ?" icon="important" />
        <paragraph>
          Attention, comme en algo, lors de la déclaration d’une variable, <formatted style="bold">celle-ci n’a pas de valeur</formatted> ! 
          Nous verrons que c’est l’instruction d’affectation qui va servir à donner un contenu aux variables déclarées.
        </paragraph>
        </clarify>
      
			  <clarify>
			  <paragraph title="Comment nommer correctement une variable ?" icon="icon_question" />
        <paragraph>
          Le but est de trouver un nom qui soit suffisamment <formatted style="bold">court</formatted>, 
          tout en restant <formatted style="bold">explicite</formatted> et ne prêtant <formatted style="bold">pas à confusion</formatted>.
        </paragraph>
        <paragraph>
          Il faut aussi tenir compte des limitations du langage.
          <list listStyle="unordered">
            <item>
            Un nom de variable est généralement une suite de caractères alphanumériques d’un
            seul tenant (pas de caractères blancs) et ne commençant jamais par un chiffre. Ainsi
            <formatted style="code">x1</formatted> est correct mais pas <formatted style="code">1x</formatted>.
            </item>
            <item>
            Un nom de variable ne peut comporter que des lettres, des chiffres, les caractères <formatted style="code">_</formatted> et <formatted style="code">$</formatted>.
            </item>
            <item>
            L’écriture de noms de variables composés
            est la notation « chameau » (camelCase en anglais), qui consiste à mettre une majuscule
            au début des mots (généralement à partir du deuxième), par exemple <formatted style="code">premierNombre</formatted>
            ou <formatted style="code">dateNaissance</formatted>.
            </item>
            <item>
            Pour donner un nom composé à une constante, on utilise le « tiret bas » ou underscore 
            (par ex. <formatted style="code">PREMIER_NUMERATEUR</formatted>).
            </item>
            <item>
            Les mots-clés du langage sont interdits (par exemple <formatted style="code">for</formatted>, <formatted style="code">if</formatted>, <formatted style="code">while</formatted>)
            </item>
          </list>
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="Comment déclarer" shuffle="yes">
						<fillInBlanks>
							<question>
							  Quelle instruction permet de déclarer :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>le jour d'une date ?<gap answers="int jour;">int jour;</gap></item>  
									<item>l'heure d'un moment ? <gap answers="int heure;">int heure;</gap></item>  
									<item>le prix d’un produit en grande surface ? <gap answers="double prix;">double prix;</gap></item>  
									<item>votre nom ? <gap answers="String nom;">String nom;</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
				
				<clarify>
				  <paragraph>
				    Une constante s’écrit grâce au mot clé <formatted style="code">final</formatted>.
            Par exemple,
<paragraph cssClass="java">
final int X = 1;
final int Y;
Y = 2*X;
X = 2; // Erreur : a une valeur
Y = 3; // Idem
</paragraph>
				  </paragraph>
				</clarify>
      </learningObject>
	</unit>
	
	
	<!-- =================================================================== -->
	<unit label="OperateursEtExpressions" title="Opérateurs et expressions">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Les <formatted style="bold">opérateurs</formatted> agissent sur les <formatted style="bold">variables</formatted> 
				et les <formatted style="bold">constantes</formatted> pour former des <formatted style="bold">expressions</formatted>. 
      </paragraph>
      <paragraph>
				Une expression est donc une combinaison cohérente de variables, de constantes et d’opérateurs,
				éventuellement accompagnés de parenthèses.
			</paragraph>
    </entry>
    
			<learningObject title="Les opérateurs arithmétiques élémentaires en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont les opérateurs binaires bien connus :
          <list listStyle="unordered">
            <item><formatted style="code">+</formatted> addition</item>
            <item><formatted style="code">-</formatted> soustraction</item>
            <item><formatted style="code">*</formatted> multiplication</item>
            <item><formatted style="code">/</formatted> division réelle</item>
          </list>
          Ils agissent sur des variables ou expressions à valeurs entières ou réelles. 
        </paragraph>
        <paragraph>
          Plusieurs opérateurs peuvent être utilisés pour former des expressions plus ou moins complexes, 
          en tenant compte des règles de calcul habituelles, notamment la priorité de la multiplication et de la division
          sur l’addition et la soustraction. 
        </paragraph>
        <paragraph>
          Il est aussi permis d’utiliser des parenthèses, par exemple <formatted style="input">a – (b + c * d)/x</formatted>. 
        </paragraph>
        <paragraph>
          Tout emploi de la division devra être accompagné d’une réflexion sur la
          valeur du dénominateur, une division par 0 entrainant toujours l’arrêt d’un algorithme.
        </paragraph>
        </clarify>
      </learningObject>


			<learningObject title="Les opérateurs DIV et MOD en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont deux opérateurs qui ne peuvent s’utiliser qu’avec des variables entières :
          <list listStyle="unordered">
            <item><formatted style="code">DIV</formatted> division entière</item>
            <item><formatted style="code">MOD</formatted> reste de la division entière</item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
      
			<learningObject title="Les opérateurs arithmétiques élémentaires en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont les opérateurs binaires bien connus :
          <list listStyle="unordered">
            <item><formatted style="code">+</formatted> addition</item>
            <item><formatted style="code">-</formatted> soustraction</item>
            <item><formatted style="code">*</formatted> multiplication</item>
            <item><formatted style="code">/</formatted> division réelle si au moins un des deux opérandes est réel</item>
            <item><formatted style="code">/</formatted> division entière si les deux opérandes sont entiers</item>
          </list>
          Ils agissent sur des variables ou expressions à valeurs entières ou réelles. 
        </paragraph>
        <paragraph>
          Plusieurs opérateurs peuvent être utilisés pour former des expressions plus ou moins complexes, 
          en tenant compte des règles de calcul habituelles, notamment la priorité de la multiplication et de la division
          sur l’addition et la soustraction. 
        </paragraph>
        <paragraph>
          Il est aussi permis d’utiliser des parenthèses, par exemple <formatted style="input">a – (b + c * d)/x</formatted>. 
        </paragraph>
        <paragraph>
          Tout emploi de la division devra être accompagné d’une réflexion sur la
          valeur du dénominateur, une division par 0 entrainant un arrêt du programme.
        </paragraph>
        </clarify>
      </learningObject>
      
      
			<learningObject title="Les opérateurs DIV et MOD en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont deux opérateurs qui ne peuvent s’utiliser qu’avec des variables entières :
          <list listStyle="unordered">
            <item><formatted style="code">/</formatted> division entière si les deux opérandes sont entiers</item>
            <item><formatted style="code">%</formatted> reste de la division entière</item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
      
      <learningObject title="Les opérateurs de comparaison en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont des opérateurs qui ne peuvent s’utiliser qu’avec des expressions numériques ou des chaines :
          <list listStyle="unordered">
            <item><formatted style="code"><![CDATA[<]]></formatted> inférieur </item>
            <item><formatted style="code"><![CDATA[≤]]></formatted> inférieur ou égal </item>
            <item><formatted style="code"><![CDATA[>]]></formatted> supérieur </item>
            <item><formatted style="code"><![CDATA[≥]]></formatted> supérieur ou égal </item></list>
          Et il y a 2 opérateurs qui peuvent s’utiliser avec des expressions de tous les types :
          <list listStyle="unordered">
            <item><formatted style="code"><![CDATA[=]]></formatted> égal </item>
            <item><formatted style="code"><![CDATA[<>]]></formatted> ou <formatted style="code"><![CDATA[≠]]></formatted> différent </item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
      <learningObject title="Les opérateurs de comparaison en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont des opérateurs qui ne peuvent s’utiliser qu’avec des expressions numériques :
          <list listStyle="unordered">
            <item><formatted style="code"><![CDATA[<]]></formatted> inférieur </item>
            <item><formatted style="code"><![CDATA[<=]]></formatted> inférieur ou égal </item>
            <item><formatted style="code"><![CDATA[>]]></formatted> supérieur </item>
            <item><formatted style="code"><![CDATA[>=]]></formatted> supérieur ou égal </item>
          </list>
          Et il y a 2 opérateurs qui peuvent s’utiliser avec des expressions de tous les types :
          <list listStyle="unordered">
            <item><formatted style="code"><![CDATA[==]]></formatted> égal </item>
            <item><formatted style="code"><![CDATA[!=]]></formatted> différent </item>
          </list>
        </paragraph>
        <paragraph>
          Attention toutefois, si vous voulez <formatted style="bold">comparer le contenu de 2 chaines</formatted> en Java,
          il vous faudra faire <formatted style="code">chaine1.equals(chaine2)</formatted>
          pour vérifier si elles sont égales et <formatted style="code">!chaine1.equals(chaine2)</formatted>
          pour vérifier si elles sont différentes.
        </paragraph>
        </clarify>
      </learningObject>
      
      <learningObject title="Les opérateurs booléens en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont des opérateurs qui ne peuvent s’utiliser qu’avec des expressions booléennes :
          <list listStyle="unordered">
            <item><formatted style="code">ET</formatted> et </item>
            <item><formatted style="code">OU</formatted> ou </item>
            <item><formatted style="code">NON</formatted> négation </item>
          </list>
        </paragraph>
        </clarify>
        <clarify>
          <paragraph>
            On définit deux modes d’évaluation des opérateurs ET et OU :
          </paragraph>
          <paragraph>
          <formatted style="bold">L’évaluation complète</formatted> :
          pour connaitre la valeur de <formatted style="code">cond1 ET cond2</formatted> 
          (respectivement <formatted style="code">cond1 OU cond2</formatted>), les deux
          conditions sont chacune évaluées, après quoi on évalue la valeur de vérité de l’ensemble de
          l’expression.
          </paragraph>
          <paragraph>
          <formatted style="bold">L’évaluation court-circuitée</formatted> :
          dans un premier temps, seule la première condition est testée. 
          </paragraph>
          <paragraph>
          Dans le cas du <formatted style="code">ET</formatted>, si <formatted style="code">cond1</formatted> s’avère faux, 
          il est inutile d’évaluer <formatted style="code">cond2</formatted> puisque le résultat sera faux de toute façon ;
          l’évaluation de <formatted style="code">cond2</formatted> 
          et de l’ensemble de la conjonction ne se fera que si <formatted style="code">cond1</formatted> est vrai.
          </paragraph>
          <paragraph>
          De même, dans le cas du <formatted style="code">OU</formatted>, si <formatted style="code">cond1</formatted> s’avère vrai, 
          il est inutile d’évaluer <formatted style="code">cond2</formatted> puisque le
          résultat sera vrai de toute façon ; l’évaluation de <formatted style="code">cond2</formatted> et de l’ensemble de la disjonction
          ne se fera que si <formatted style="code">cond1</formatted> est faux.
          </paragraph>
          <paragraph>
          Dans le cadre de ce cours, nous opterons pour la deuxième interprétation. 
          </paragraph>
          <paragraph>
          Montrons son avantage sur un exemple. 
          </paragraph>
          <paragraph>
          Considérons l’expression <formatted style="code">n ≠ 0 ET m/n > 10</formatted>. Si on teste sa valeur
          de vérité avec une valeur de <formatted style="code">n</formatted> non nulle, la première condition est vraie et le résultat de
          la conjonction dépendra de la valeur de la deuxième condition. Supposons à présent que <formatted style="code">n</formatted>
          soit nul. L’évaluation court-circuitée donne le résultat faux immédiatement après test de la
          première condition sans évaluer la seconde, tandis que l’évaluation complète entrainerait un
          arrêt de l’algorithme pour cause de division par 0 !
          </paragraph>
          <paragraph>
          Notez que l’évaluation court-circuitée a pour conséquence la non-commutativité du 
          <formatted style="code">ET</formatted> et du <formatted style="code">OU</formatted> : 
          <formatted style="code">cond1 ET cond2</formatted> n'est pas la même que <formatted style="code">cond2 ET cond1</formatted>, 
          puisque l’ordre des évaluations des deux conditions entre en jeu.
          </paragraph>
        </clarify>
      </learningObject>
      
      <learningObject title="Les opérateurs booléens en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont des opérateurs qui ne peuvent s’utiliser qu’avec des expressions booléennes :
          <list listStyle="unordered">
            <item><formatted style="code"><![CDATA[&&]]></formatted> et </item>
            <item><formatted style="code"><![CDATA[||]]></formatted> ou </item>
            <item><formatted style="code"><![CDATA[!]]></formatted> négation </item>
          </list>
          Java utilise l'évaluation court-circuitée.
        </paragraph>
        </clarify>
      </learningObject>
      
      <learningObject title="Les fonctions mathématiques complexes en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          <list listStyle="unordered">
            <item>L’élévation à la puissance sera notée ** ou ˆ . </item>
            <item>Pour la racine carrée d’une variable x nous écrirons √x . Attention, pour ce dernier, de veiller à ne l’utiliser qu’avec un radicant positif !
            Exemple : <formatted style="code">(−b +√(b ∗ ∗2 − 4 ∗ a ∗ c))/(2 ∗ a)</formatted></item>
            <item> À votre avis, pourquoi ne pas avoir écrit « 4ac » et « 2a » ?</item>
            <item>Si nécessaire, on se permettra d’utiliser les autres fonctions mathématiques sous leur forme
            la plus courante dans la plupart des langages de programmation (exemples : sin(x), tan(x), log(x), exp(x). . .)</item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    
    <learningObject title="Les fonctions mathématiques complexes en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
        L'essentiel des fonctions mathématiques se trouvent dans la classe Math.
          <list listStyle="unordered">
            <item><formatted style="code">Math.pow(a,b)</formatted> est l'élévation à la puissance aˆb</item>
            <item><formatted style="code">Math.sqrt(x)</formatted> est la racine carrée d’une variable x, √x . Attention, pour ce dernier, de veiller à ne l’utiliser qu’avec un radicant positif, sinon, une exception sera générée !</item>
            <item>Si nécessaire, les autres fonctions mathématiques <formatted style="code">Math.sin(x)</formatted>, 
            <formatted style="code">Math.tan(x)</formatted>, <formatted style="code">Math.log(x)</formatted>, <formatted style="code">Math.exp(x)</formatted>. . .</item>
            <item>Toutes les informations se trouvent dans l'<link uri="http://docs.oracle.com/javase/8/docs/api/">API</link>, à la classe Math.</item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    
    <learningObject title="Exercices">
			<!-- ============================================================ -->
			  <act>
				<selfCheck title="Que vaut ?" shuffle="yes">
						<fillInBlanks>
							<question>
							  en algo :
							</question>
							<gapText> 
								<list listStyle="unordered">
								  <item>15 + 3 ? <gap answers="18">18</gap></item>  
								  <item>17 - 2 ? <gap answers="15">15</gap></item>  
								  <item>13/2 ? <gap answers="6.5">6.5</gap></item>  
								  <item>4.5*3 ? <gap answers="13.5">13.5</gap></item>  
									<item>15 DIV 4 ? <gap answers="3">3</gap></item>  
									<item>17 MOD 3 ? <gap answers="2">2</gap></item>  
									<item>'x'='y' ? <gap answers="faux">faux</gap></item>  
									<item>7<![CDATA[<]]>8 ? <gap answers="vrai">vrai</gap></item>  
									<item>0<![CDATA[≥]]>0 ? <gap answers="vrai">vrai</gap></item>  
									<item>3<![CDATA[≥]]>4 ET 4<![CDATA[<]]>8 ? <gap answers="faux">faux</gap></item>  
									<item>3<![CDATA[≥]]>4 OU 4<![CDATA[<]]>8 ? <gap answers="vrai">vrai</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
          </selfCheck>
        
				<selfCheck title="Que vaut ?" shuffle="yes">
						<fillInBlanks>
							<question>
							  en java :
							</question>
							<gapText> 
								<list listStyle="unordered">
								  <item>21 + 3 ? <gap answers="24">24</gap></item>  
								  <item>1 - 2 ? <gap answers="-1">-1</gap></item>  
								  <item>13/2 ? <gap answers="6">6</gap></item>  
								  <item>4.5*3 ? <gap answers="13.5">13.5</gap></item>  
									<item>13.0/2 ? <gap answers="6.5">6.5</gap></item>  
									<item>15 % 3 ? <gap answers="0">0</gap></item>  
									<item>'a'=='b' ? <gap answers="false">false</gap></item>  
									<item>7<![CDATA[<]]>8 ? <gap answers="true">true</gap></item>  
									<item>0<![CDATA[<=]]>0 ? <gap answers="true">true</gap></item>  
									<item>-1<![CDATA[<=]]>4 <![CDATA[&&]]> 4<![CDATA[>]]>8 ? <gap answers="false">false</gap></item>  
									<item>-1<![CDATA[>=]]>4 <![CDATA[||]]> 4<![CDATA[<]]>8 ? <gap answers="true">true</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
    </learningObject>
    </unit>
    
    
	<!-- =================================================================== -->
	<unit label="Affectation" title="L’affectation d’une valeur à une variable">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Cette opération est probablement l’opération la plus importante. En effet, une variable ne
        prend son sens réel que si elle reçoit à un moment donné une valeur. Il y a deux moyens de
        donner une valeur à une variable.
      </paragraph>
    </entry>
    
			<learningObject title="Affectation interne en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation interne</formatted> lorsque la valeur d’une variable est « calculée » par l’exécutant
          de l’algorithme lui-même à partir de données qu’il connait déjà :
          <formatted style="input">nomVariable ← expression</formatted>
          (une expression est une combinaison de variables et d’opérateurs). <formatted style="bold">L’expression a une valeur</formatted>.
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="" shuffle="yes">
					<multipleChoice>
						<question>Les exemples d’affectation sont-ils corrects ?
						</question>
						<answer feedback="" correct="yes">somme ← nombre1 + nombre2</answer>
						<answer feedback="" correct="yes">denRes ← den1 * den2</answer>
						<answer feedback="" correct="yes">cpt ← cpt + 1</answer>
						<answer feedback="" correct="yes">delta ← b**2 – 4*a*c</answer>
						<answer feedback="" correct="yes">maChaine ← "Bonjour"</answer>
						<answer feedback="" correct="yes">test ← a = b</answer>
						<answer feedback="À gauche de l'affectation, on doit trouver une variable, pas une expression" correct="no">somme + 1 ← 3</answer>
						<answer feedback="Il manque un opérateur entre 3 et n. 3n n'est pas non plus un nom de variable correct" correct="no">somme ← 3n</answer>
					</multipleChoice>
				</selfCheck>
				</act>
				<paragraph>
				Remarques
				<list listStyle="unordered">
            <item>
              Il est de règle que le résultat de l’expression à droite du signe d’affectation (←) soit de
              même type que la variable à sa gauche. On tolère certaines exceptions :
              <list listStyle="unordered">
                <item>
                  <formatted style="code">varEntière ← varRéelle</formatted> : dans ce cas le contenu de la variable sera la valeur tronquée de l’expression réelle. <newLine/>
                  Par exemple si <formatted style="code">nb</formatted> est une variable de type entier,
                  son contenu après l’instruction <formatted style="input">nb ← 15/4 </formatted> sera 3.
                </item>
                <item><formatted style="code">varRéelle ← varEntière</formatted> : ici, il n’y a pas de perte de valeur.</item>
              </list>
            </item>
            <item>
            Seules les variables déclarées peuvent être affectées, que ce soit par l’affectation externe
            ou interne !
            </item>
            <item>
            Nous ne mélangerons pas la déclaration d’une variable et son affectation interne dans
            une même ligne de code, donc pas d’instructions hybrides du genre <formatted style="code">x ← 2 : entier</formatted> ou
            encore <formatted style="code">x : entier(0)</formatted>.
            </item>
            <item>
            Pour l’affectation interne, toutes les variables apparaissant dans l’expression doivent
            avoir été affectées préalablement. Le contraire provoquerait un arrêt de l’algorithme.
            </item>
          </list>
        </paragraph>
      </learningObject>
      
      <learningObject title="Affectation interne en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation interne</formatted> lorsque la valeur d’une variable est « calculée » par l’exécutant
          de l’algorithme lui-même à partir de données qu’il connait déjà :
          <formatted style="input">nomVariable = expression;</formatted>
          (une expression est une combinaison de variables et d’opérateurs). <formatted style="bold">L’expression a une valeur</formatted>.
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="" shuffle="yes">
					<multipleChoice>
						<question>Les exemples d’affectation sont-ils corrects ?
						</question>
						<answer feedback="" correct="yes">somme = nombre1 + nombre2;</answer>
						<answer feedback="" correct="yes">denRes = den1 * den2;</answer>
						<answer feedback="" correct="yes">cpt = cpt + 1;</answer>
						<answer feedback="" correct="yes">delta = Math.pow(b,2) – 4*a*c;</answer>
						<answer feedback="" correct="yes">maChaine = "Bonjour";</answer>
						<answer feedback="À gauche de l'affectation, on doit trouver une variable, pas une expression" correct="no">somme + 1 = 3;</answer>
						<answer feedback="Il manque un opérateur entre 3 et n. 3n n'est pas non plus un nom de variable correct" correct="no">somme = 3n;</answer>
					</multipleChoice>
				</selfCheck>
				</act>
      </learningObject>
      
			<learningObject title="Affectation externe en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation externe</formatted> lorsque la valeur à affecter à une variable
           est donnée par l’utilisateur qui la communique à l’exécutant quand celui-ci le lui demande : 
           cette valeur est
          donc externe à la procédure (l’ordinateur ne peut la deviner lui-même !)
        </paragraph>
        <paragraph>
          L’affectation externe est donc la primitive qui permet de recevoir de l’utilisateur, au moment
          où l’algorithme se déroule, une ou plusieurs valeur(s) et de les affecter à des variables en
          mémoire. 
        </paragraph>
        <paragraph>
          Nous noterons :
          <formatted style="input">demander liste_de_variables_à_lire</formatted>
        </paragraph>
        <paragraph>
          Exemples :<newLine/><newLine/>
          <formatted style="input">demander nombre1, nombre2</formatted><newLine/><newLine/>
          <formatted style="input">demander num1, den1, num2, den2</formatted>
        </paragraph>
        <paragraph>
          L’exécution de cette instruction provoque une pause dans le déroulement de l’algorithme ;
          l’exécutant demande alors à l’utilisateur les valeurs des variables à lire. Ces valeurs viennent
          donc de l’extérieur ; une fois introduites dans le système, elles sont affectées aux variables
          concernées et l’algorithme peut reprendre son cours. Les possibilités d’introduction de données
          sont nombreuses : citons par exemple l’encodage de données au clavier, un clic de souris,
          le toucher d’un écran tactile, des données provenant d’un fichier, etc.
        </paragraph>
        </clarify>
        </learningObject>
        
        
			<learningObject title="Affectation externe en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation externe</formatted> lorsque la valeur à affecter à une variable
           est donnée par l’utilisateur qui la communique à l’exécutant quand celui-ci le lui demande : cette valeur est
          donc externe à la procédure (l’ordinateur ne peut la deviner lui-même !)
        </paragraph>
        <paragraph>
          L’affectation externe est donc la primitive qui permet de recevoir de l’utilisateur, au moment
          où l’algorithme se déroule, une ou plusieurs valeur(s) et de les affecter à des variables en
          mémoire. 
        </paragraph>
        <paragraph>
          Nous noterons :
          </paragraph>
          <paragraph cssClass="java">
import java.util.Scanner;
// ...
Scanner clavier = new Scanner(System.in);
// ...
int nombre1 = clavier.nextInt();
				</paragraph>
        <paragraph>
          Les différentes lectures possibles sont :
          <list listStyle="unordered">
            <item>pour un entier : clavier.nextInt();</item>
            <item>pour un réel : clavier.nextDouble();</item>
            <item>pour un booléen : clavier.nextBoolean();</item>
            <item>pour un mot : clavier.next()</item>
            <item>pour une ligne : clavier.nextLine();</item>
            <item>pour un caractère : clavier.next.charAt(0);</item>
          </list>
        </paragraph>
        </clarify>
        </learningObject>
        
        <learningObject title="Communication des résultats en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          L’instruction de communication des résultats consiste à donner à l’extérieur (donc à l’utilisateur) 
          la valeur d’un résultat calculé au cours de l’exécution de l’algorithme.
        </paragraph>
        <paragraph>
          Nous noterons :
          <formatted style="input">afficher expression ou liste de variables séparées par des virgules</formatted>
          qui signifie que la valeur d’une expression (ou celles des différentes variables mentionnées) 
          sera fournie à l’utilisateur (par exemple par un affichage à l’écran ou par impression sur
          listing via l’imprimante, etc.).
          </paragraph>
          <paragraph>
          Exemples <newLine/><newLine/>
          <formatted style="input">afficher nb1</formatted><newLine/><newLine/>
          <formatted style="input">afficher "Le premier nombre vaut ", nb1, " et le seconde nombre vaut ", nb2 </formatted>
          </paragraph>
          <paragraph>
          Comme pour l’affectation interne, on ne peut afficher que des expressions dont les
          variables qui la composent ont été affectées préalablement.
          </paragraph>
        </clarify>
        </learningObject>
        
        <learningObject title="Communication des résultats en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          L’affichage de la valeur d'une variable <formatted style="input">var</formatted>  est donnée par l'instruction
          </paragraph>
          <paragraph cssClass="java">
 System.out.println(var);
				</paragraph>
        <paragraph>
          Si nous voulons précéder l'affichage de la valeur d'une variable <formatted style="input">var</formatted>  par un message, 
          nous utiliserons l'instruction
        </paragraph>
        <paragraph cssClass="java">
 System.out.println("La variable var vaut " + var);
				</paragraph>
        </clarify>
        </learningObject>
        
        
    <learningObject title="Exercices">
			<!-- ============================================================ -->
			  <act>
				<selfCheck title="Que vaut ?" shuffle="yes">
						<fillInBlanks>
							<question>
							  en algo :
							</question>
							<gapText> 
								<list listStyle="unordered">
								  <item>Quel est le contenu de la variable entière n à l'issue de ces 2 lignes de code?<newLine/>
                    n ← 5<newLine/>
                    n ← 1 + n*2<newLine/>
                    <gap answers="11">11</gap></item>  
								  <item>Quel est le contenu de la variable entière n à l'issue de ces 3 lignes de code?<newLine/>
                    n ← 25<newLine/>
                    n ← n DIV 2<newLine/>
                    n ← n MOD 7 ? <newLine/>
                    <gap answers="5">5</gap></item>  
								  <item>Quelle est l'instruction qui réalise l'affectation externe de la variable capital ?<gap answers="demander capital">demander capital</gap></item>  
								  <item>Quelle est l'instruction qui permet d'afficher le contenu de la variable salaire ?<gap answers="afficher salaire">afficher salaire</gap></item>  
									<item>Dans un algorithme, on veut mettre dans la variable c le produit des contenus des
									  variables a et b. Que doit-on écrire?<gap answers="c ← a*b">c ← a*b</gap></item>  
									<item>Écrivez l'instruction qui a pour effet de mettre clr dans la variable acronyme (de type chaine) <gap answers="">acronyme ← "clr"</gap></item>  
									<item>Que va afficher le programme suivant si l’utilisateur encode « Toto » ?<newLine/>
									  monNom : chaine<newLine/>
									  demander monNom<newLine/>
                    afficher « monNom »<newLine/>
                    <gap answers="monNom">monNom</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
          </selfCheck>
        
				<selfCheck title="Que vaut ?" shuffle="yes">
						<fillInBlanks>
							<question>
							  en java :
							</question>
							<gapText> 
								<list listStyle="unordered">
								  <item>Quel est le contenu de la variable entière n à l'issue de ces 2 lignes de code?<newLine/>
                    int n = 8;<newLine/>
                    n = 6 + n/3;<newLine/>
                    <gap answers="8">8</gap></item>  
								  <item>Quel est le contenu de la variable entière n à l'issue de ces 3 lignes de code?<newLine/>
                    int n = 13<newLine/>
                    n ← n / 2<newLine/>
                    n ← n % 3 ? <newLine/>
                    <gap answers="0">0</gap></item>  
                  <item>Quelle est la ligne de code qui déclare et crée la variable clavier permettant l'accès au clavier en entrée ? <gap answers="">Scanner clavier = new Scanner(System.in);</gap></item>  
								  <item>Quelle est la ligne de code qui réalise l'affectation externe de la variable réelle capital ? <gap answers="">capital=clavier.nextDouble();</gap></item>  
								  <item>Quelle est la ligne de code qui permet d'aller à la ligne ? <gap answers="">System.out.println();</gap></item>  
								  <item>Quelle est la ligne de code qui permet d'afficher le contenu de la variable salaire et d'aller à la ligne ? <gap answers="">System.out.println(salaire);</gap></item>  
									<item>Dans un code java, on veut mettre dans la variable c le produit des contenus des
									  variables a et b. Que doit-on écrire ? <gap answers="c = a*b;">c = a*b;</gap></item>  
									<item>Écrivez l'instruction qui a pour effet de mettre clr dans la variable acronyme (de type chaine) <gap answers="">acronyme = "clr";</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
    </learningObject>
    </unit>
    
    
    <!-- =================================================================== -->
	<unit label="Commentaires" title="Documenter son code">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				On n’insistera jamais assez sur la nécessité de documenter un algorithme en y insérant 
        des commentaires judicieux, clairs et suffisants !
        
        Dans un premier temps, vous pourrez utiliser les commentaires pour documenter votre code.
      </paragraph>
    </entry>
    
    
    <learningObject title="Documenter son algorithme">
    <!-- ============================================================ -->
    <clarify>
      <paragraph>
        Un commentaire est un texte placé dans l’algorithme et destiné à faciliter au maximum 
        la compréhension d’un algorithme par le lecteur (parfois une autre personne, 
        mais aussi souvent l’auteur qui se perd dans son propre texte lorsqu’il s’y replonge après une interruption). 
      </paragraph>
      <paragraph>
        Ces commentaires (introduits par « // ») seront bien entendu ignorés par l’exécutant de l’algorithme.
      </paragraph>
      <paragraph>
        Notez qu’un excès de commentaires peut être aussi nuisible qu’un trop-peu pour la 
        compréhension d’un algorithme. 
        Par exemple, un choix judicieux de noms de variables peut s’avérer bien plus efficace que des commentaires superflus.
      </paragraph>
      <paragraph>
        Nous prendrons l’habitude de commenter chaque algorithme en précisant ce qu’il fait.
      </paragraph>
    </clarify>
    </learningObject>
    
    <learningObject title="Documenter son code Java">
    <!-- ====================================== -->
    <clarify>
      <paragraph>
      Dans un premier temps, vous pourrez documenter votre code à l'aide de commentaires.
      </paragraph>
      
      <paragraph>Il existe plusieurs manières d’ajouter un commentaire</paragraph>
      <paragraph cssClass="java">
// Commentaire sur une ligne
</paragraph>
      <paragraph cssClass="java">
/* Commentaire sur
  plusieurs lignes */
</paragraph>
      <paragraph>
      En Java,il existe toutefois un outil bien plus puissant pour commenter son code, il s'agit de la javadoc.
      Nous en reparlerons plus loin.
      </paragraph>
    </clarify>
    </learningObject>
  </unit>
  
	<!-- =================================================================== -->
	<unit label="Structure" title="Structure générale">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Voyons maintenant comment démarrer les algo et le code Java.
      </paragraph>
    </entry>
    
    <learningObject title="Structure générale d’un algorithme">
    <!-- ============================================= -->
      <clarify>
        <paragraph>
          Un algorithme contient la solution algorithmique d’un problème donné (ou d’une de ses parties).
        </paragraph>
        <paragraph>
			    <multimedia src="../image/methode.png" type="png" />
        </paragraph>
        <paragraph>
          Sa structure générale sera la suivante :
        </paragraph>
        <paragraph cssClass="code">
algorithme nomAlgorithme(paramètres)
    instructions
fin algorithme
				</paragraph>
        <paragraph cssClass="code">
algorithme nomAlgorithme(paramètres) → type
    instructions
    retourner expression
fin algorithme
				</paragraph>
				
				<paragraph>Par exemple,</paragraph>
				<paragraph cssClass="code">
algorithme sommerNombres(nb1, nb2 : réels) → réel
    retourner nb1 + nb2
fin algorithme
				</paragraph>
				
        <paragraph>
          Remarques :
          <list listStyle="unordered">
            <item>Le code d’un algorithme sera toujours compris entre la première ligne, 
            appelée « <formatted style="bold">entête</formatted> » qui commence par le mot « algorithme » suivi du nom choisi pour l’algorithme,
            et la ligne finale « fin algorithme ».
            </item> 
            <item>Le code compris entre l’entête et la ligne finale sera toujours légèrement décalé vers la droite, 
              c’est un premier exemple d’<formatted style="bold">indentation</formatted> indispensable pour la lisibilité d’un programme, 
              nous y reviendrons lors de l’étude des structures alternatives et répétitives.
            </item>
            <item>Comme pour les variables, le <formatted style="bold">nomAlgorithme</formatted> 
            devra être <formatted style="bold">approprié</formatted> au contenu ! 
            Par exemple, sommerNombres(nb1, nb2 : réels), additionnerFractions(num1, num2, dén1, dén2 : entiers) plutôt que goPartez() ! 
            </item>
            <item>Il va de soi que toutes les parties de cette structure générale ne seront pas toujours 
            nécessaires : certains algorithmes ne nécessiteront pas de passage de paramètres, d’autres 
            ne devront pas communiquer un résultat...
            </item>
            <item>Pour la <formatted style="bold">lisibilité</formatted>, 
            on veillera toujours à ce qu’un algorithme tienne sur une vingtaine de 
            lignes (donc, en pratique, sur un écran de 40 x 80 caractères ou une page). 
            </item>
            <item>
            Il devra résoudre un seul problème.
            </item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    
    <learningObject title="Structure générale d’un programme Java">
    <!-- ============================================================ -->
      <clarify>
        <paragraph>
          Tout programme Java s'écrit dans une <formatted style="bold">classe</formatted>. 
          <list listStyle="unordered">
            <item>Cette classe doit porter le même nom que le fichier ;</item>
            <item>elle commence par une majuscule ; </item>
            <item>elle doit avoir un nom explicite.</item>
          </list>
        </paragraph>
        <paragraph>
          <formatted style="input">$cat NomClasse.java</formatted>
        </paragraph>
        <paragraph cssClass="java">
public class NomClasse {
    // insert code here
}
        </paragraph>
        <paragraph title="Attention à la casse" icon="important" />
        <paragraph>
          Attention Java est sensible à la casse, il différencie majuscules et minuscules.
        </paragraph>
      </clarify>
      <clarify>
      
         <paragraph>
          <formatted style="bold">Méthode</formatted> est le mot Java équivalent d'"algorithme".
        </paragraph>
        <paragraph>
          Voici par exemple la méthode 
        </paragraph>
        <paragraph cssClass="java">
public class NomClasse {
    public static double sommerNombres(double nb1, double nb2)
        retourner nb1 + nb2;
    }
}
        </paragraph>
        <paragraph>
          Quand un programme Java s'exécute, il démarre à la méthode principale.
        </paragraph>
        <paragraph>
          La méthode principale s'appelle <formatted style="input">public static void main(String [] args) </formatted> et s'insère dans la classe de la façon suivante :
        </paragraph>
        <paragraph cssClass="java">
public class NomClasse {
    public static void main(String [] args) {
        // insert code here
    }
}
        </paragraph>
        <paragraph>
          On peut aussi y ajouter une lecture au clavier par exemple :
        </paragraph>
        <paragraph cssClass="java">
import java.util.Scanner;
public class NomClasse {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        double nombre1 = clavier.nextDouble();
        double nombre2 = clavier.nextDouble();
        double somme = sommerNombres(nombre1, nombre2);
        System.out.println("La somme de " + nombre1 + " et de " + nombre2 + " vaut " + somme);
    }
    public static double sommerNombres(double nb1, double nb2)
        retourner nb1 + nb2;
    }
}
        </paragraph>
      </clarify>
    </learningObject>
  </unit>
  
  <!-- =================================================================== -->
	<unit label="CompilerExecuter" title="Compiler et exécuter un programme Java">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Nous avons vu maintenant comment écrire un programme en Java. Il faut maintenant voir comment le "lancer".
      </paragraph>
    </entry>
    
    <learningObject title="Java est un langage compilé puis interprété">
    <!-- ============================================================ -->
      <clarify>
        <paragraph>
			    <multimedia src="../image/java-jvm-jvm.png" type="png" />
        </paragraph>
        
        <paragraph>
          Prenons un exemple (fichier<formatted style="code"> Hello . java</formatted>)
          </paragraph>
          
        <paragraph cssClass="java">
// Mon premier programme
public class Hello {
    public static void main(String[] args) {
        System.out.println ("Bonjour !");
    }
}
        </paragraph>
        <paragraph>
        <list listStyle="unordered">
            <item>Compilons-le <formatted style="input">javac Hello.java</formatted></item>
            <item>On obtient la version compilée, le bytecode (<formatted style="code">Hello.class</formatted> )</item>
            <item>On peut l’exécuter <formatted style="input">java Hello</formatted></item>
            <item>On voit alors apparaitre à l'écran <formatted style="code">Bonjour !</formatted></item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
  </unit>
  
  
	<!-- =================================================================== -->
	<unit label="Exercices" title="Exercices">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Maintenant, mettons tout ça en pratique.
      </paragraph>
    </entry>
    
    <learningObject title="Compréhension d’algorithme">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des algorithmes donnés. 
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils retourner si à chaque fois les deux nombres reçus au départ sont successivement 2 et 3 ?
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="code">
algorithme exerciceA (a, b : entiers) → entier
  b ← b+2*a
  retourner b
fin algorithme
				</paragraph>
				            <gap answers="7">7</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
algorithme exerciceB (a, b : entiers) → entier
  a ← a+2*b
  retourner a
fin algorithme
				</paragraph>
				            <gap answers="8">8</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
algorithme exerciceC (b, a : entiers) → entier
  b ← b+2*a
  retourner b
fin algorithme
				</paragraph>
				            <gap answers="8">8</gap> 
									</item>
									<item>
										<paragraph cssClass="code">
algorithme exerciceD (a, b : entiers) → réel
  retourner a / b
fin algorithme
				</paragraph>
				            <gap answers="0">0</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
algorithme exerciceE () → entier
  a, b, c, d : entiers
  demander c, d
  a ← 2*c+5*d
  b ← 2+c*3+d
  c ← a MOD b
  retourner a DIV c
fin algorithme
				</paragraph>
				            <gap answers="2">2</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
algorithme exerciceF (x, y : réels) → réel
  x ← x*x 
  x ← x*x+y*y 
  x ← √x
  retourner x
fin algorithme
				</paragraph>
				            <gap answers="5">5.0</gap> 
									</item>  
									<item>
										<paragraph cssClass="code">
algorithme exerciceG() → réel
  x, y : réels
  demander x, x
  x ← x MOD x + (x + 1) DIV 2
  retourner x + 3
fin algorithme
				</paragraph>
				            <gap answers="5">5</gap> 
									</item>  
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
        </paragraph>
      </act>
    </learningObject>
      
    <learningObject title="Compréhension de codes Java">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          Pour ces exercices, nous vous demandons de comprendre des codes Java donnés. 
        </paragraph>
          <selfCheck title="Compréhension" shuffle="no">
						<fillInBlanks>
							<question>
							  Que vont-ils afficher si à chaque fois les deux nombres lus au départ sont successivement 2 et 3 ?
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice1 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(nb1 + " " + nb2);
    }
}
        </paragraph>
				            <gap answers="2 3">2 3</gap> 
									</item>  
									
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice2 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        int nb3 = exercice(nb1, nb2);
        System.out.println(nb3);
    }
    public static int exercice(int nb1, int nb2) {
        retourner 2*nb1 + nb2;
    }
}
        </paragraph>
				            <gap answers="7">7</gap> 
									</item>  
									
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice3 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb2 = clavier.nextInt();
        int nb1 = clavier.nextInt();
        int nb3 = exercice(nb1, nb2);
        System.out.println(nb3);
    }
    public static int exercice(int nb1, int nb2) {
        retourner 2*nb1 + nb2;
    }
}
        </paragraph>
				            <gap answers="8">8</gap> 
									</item>  
									
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice4 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(2*nb1 + nb2);
    }
}
        </paragraph>
				            <gap answers="7">7</gap> 
									</item>  
									
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice5 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(nb2/nb1);
    }
}
        </paragraph>
				            <gap answers="1">1</gap> 
									</item> 
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice6 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        int nb2 = clavier.nextInt();
        System.out.println(nb1%nb2);
    }
}
        </paragraph>
				            <gap answers="2">2</gap> 
									</item> 
									
									<item>
										<paragraph cssClass="java">
import java.util.Scanner;
public class Exercice7 {
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        int nb1 = clavier.nextInt();
        nb1 = clavier.nextInt();
        nb1 = nb1 * nb1;
        System.out.println(Math.sqrt(nb1));
    }
}
        </paragraph>
				            <gap answers="3">3</gap> 
									</item>  
								</list>
							</gapText>
							<solution/>
						</fillInBlanks>
					</selfCheck>
      </act>
      </learningObject>
      
      <learningObject title="Compréhension de codes Java (suite)">
      <act>
				<selfCheck title="Comprendre les erreurs" shuffle="yes">
					<multipleChoice>
						<question>
							<paragraph>
								Soit le code :
							</paragraph>
							<paragraph cssClass="java">
  public class ErrCompilation{
	  public static void main ( string[] args ) {
		  System.out.println("Hello !");
	  }
  }							</paragraph>
							<paragraph>
								la commande "<formatted style="java">javac ErrCompilation.java</formatted>"  provoque l'erreur suivante :
							</paragraph>
							<paragraph cssClass="code">
  ErrCompilation.java:2:
  cannot find symbol
  symbol : class string
  location:class ErrCompilation
  public static void main ( string[] args ) {
  ^ 
  1
  error						</paragraph>
							<paragraph>
								Quelle est l'erreur ?
							</paragraph>
						</question>

			            <answer feedback="Non non, qu'il y ait 0, 1 ou plusieurs espaces ne change rien..." correct="no">il faut insérer des espaces dans la parenthèse</answer>
			            <answer feedback="En effet, il s'agit bien de String et non string" correct="yes">string doit être écrit avec une majuscule au début</answer>
			            <answer feedback="Non non, le fichier doit bien avoir le même nom que la classe avec l'extension java, c-à-d ErrCompilation.java" correct="no">le fichier doit s'appeler string.java</answer>
			            <answer feedback="Non non, ce sont bien des parenthèses..." correct="no">il faut remplacer les parenthèses par des accolades</answer>
					<solution></solution>
					</multipleChoice>
				</selfCheck>
     

				<selfCheck title="Comprendre les erreurs" shuffle="yes">
      					<multipleChoice>
						<question>
							<paragraph>
								Soit le code :
							</paragraph>
 							<paragraph cssClass="java">
  public class ErrExecution {
      public void main ( String[] args ) {
          System.out.println(10);
      }
  }							</paragraph>
							<paragraph>
								la suite de commandes 
							</paragraph>
							<paragraph cssClass="code">
  javac ErrExecution.java 
  java ErrExecution			</paragraph>
							<paragraph>
								provoque l'erreur suivante :
							</paragraph>
							<paragraph cssClass="code">
  Exception in thread "main" java.lang.NoSuchMethodError: main</paragraph>
							<paragraph>
								il s'agit d'une erreur générée par la machine virtuelle java car :
							</paragraph>
						</question>
						<answer feedback=" " correct="no">la machine virtuelle est mal installée</answer>
						<answer feedback=" " correct="no">le source n'a pas été compilé</answer>
						<answer feedback="il manque le mot clé static" correct="yes">l'entête de la méthode main est incorrect</answer>
						<answer feedback=" " correct="no">on exécute la mauvaise classe</answer>
						<solution>En effet, quel est-il d'ailleurs ?</solution>
					</multipleChoice>
				</selfCheck>
     

				<selfCheck title="Comprendre les erreurs" shuffle="yes">
      					<multipleChoice>
						<question>
							<paragraph>
								Soit le code :
							</paragraph>
							<paragraph cssClass="java">
  public class ErrExecution {
      public static void main ( String[] args ) {	
          System.out.println(10);
      }
  }							</paragraph>
							<paragraph>
								la suite de commandes 
							</paragraph>
							<paragraph cssClass="code">
  javac ErrExecution.java 
  java ErrExecution.java	</paragraph>
							<paragraph>
								provoque l'erreur suivante :
							</paragraph>
							<paragraph cssClass="code">
  Exception in thread "main" java.lang.NoClassDefFoundError: ErrExecution/java
  caused by: java.lang.ClassNotFoundException: ErrExecution.java
  [...]
  Could not find the main class: ErrExecution.java. Program will exit.	</paragraph>
							<paragraph>
								il s'agit d'une erreur générée par la machine virtuelle java car :
							</paragraph>
						</question>
						<answer feedback=" " correct="no">la machine virtuelle est mal installée</answer>
						<answer feedback=" " correct="no">l'entête de la méthode main est incorrect</answer>
						<answer feedback="En effet... quelle classe tente-t-il d'exécuter ? (Relisez bien la commande d'exécution)" correct="yes">on exécute le mauvais fichier</answer>
						<solution></solution>
					</multipleChoice>
				</selfCheck>

      </act>
    </learningObject>
    
    <learningObject title="À vous de jouer...">
    <!-- ============================================================ -->
      <act>
        <paragraph title="Consignes">
          Il est temps de se lancer et d’écrire vos premiers algorithmes et programmes Java correspondant. 
          Voici quelques conseils pour vous guider dans la résolution de tels problèmes :
          <list listStyle="unordered">
            <item>il convient d’abord de bien comprendre le problème posé ; assurez-vous qu’il est parfaitement spécifié ;</item>
            <item>résolvez le problème via quelques exemples précis ;</item>
            <item>mettez en évidence les variables <formatted style="bold">« données »</formatted>, les variables <formatted style="bold">« résultats »</formatted> et les variables de travail ;</item>
            <item>n’hésitez pas à faire une ébauche de résolution en français avant d’élaborer l’algorithme définitif pseudo-codé ;</item>
            <item>déclarez ensuite les variables (et leur type) qui interviennent dans l’algorithme ; les noms des variables doivent être suffisamment explicites.</item>
            <item>Écrivez la partie algorithmique <formatted style="bold">AVANT</formatted> de vous lancer dans la programmation en Java.</item>
          </list>
        </paragraph>
        
        <paragraph title="Parenthèses">
          <list listStyle="ordered">
            <item>Que vaut (((5) + 3) - 2) + (2 * 3) ?</item>
            <item>Toutes les parenthèses sont-elles obligatoires ? Si non, lesquelles pouvez-vous retirer ?</item>
            <item>Que vaut ((4/2)*(2*3)) * 5 ?</item>
            <item>Toutes les parenthèses sont-elles obligatoires ? Si non, lesquelles pouvez-vous retirer ?</item>
          </list>
        </paragraph>
        <paragraph title="Exercice résolu">
          La somme des angles d’un triangle est égale dans tous les cas à 180°. Écrivez un algorithme qui reçoit la valeur de deux angles d’un triangle, et retourne la valeur du 3e. 
        </paragraph>
        <paragraph>Par exemple, si on reçoit 40 pour le premier angle et 60 pour le second, on doit retourner 80 pour le troisième (40 + 60 = 100, le troisième angle vaut donc 80).</paragraph>
        <paragraph>Par exemple, si on reçoit 90 pour le premier angle et 10 pour le second, on doit retourner 80 pour le troisième (90 + 10 = 100, le troisième angle vaut donc 80).</paragraph>
        <paragraph>Par exemple, si on reçoit 89 pour le premier angle et 30 pour le second, on doit retourner 61 pour le troisième (89 + 30 = 119, le troisième angle vaut donc 61).</paragraph>
        <paragraph>Par exemple, si on reçoit 5 pour le premier angle et 5 pour le second, on doit retourner 170 pour le troisième (5 + 5 = 10, le troisième angle vaut donc 170).</paragraph>
        <paragraph>Par exemple, si on reçoit 0 pour le premier angle et 180 pour le second, on doit retourner 0 pour le troisième (0 + 180 = 180, le troisième angle vaut donc 0).</paragraph>
        <paragraph>
          Quelles sont les données ? :
          <list listStyle="ordered">
            <item>les 2 angles du triangle, des réels.</item>
          </list>
          Que cherche-t-on ? :
          <list listStyle="ordered">
            <item>la valeur du 3e angle du triangle, un réel.</item>
          </list>
          Comment faire ? :
          <list listStyle="ordered">
            <item>On sait que la somme des 3 angles d'un triangle vaut 180°. (angle1 + angle2 + angle3 = 180)</item>
            <item>On connait la valeur de 2 des angles, disons angle1 et angle2.</item>
            <item>La valeur du troisième angle vaut donc 180 moins la somme des 2 autres angles.(angle3 vaut 180 - (angle1 + angle2))</item>
          </list>
          Écrivons l'algorithme :
          <paragraph cssClass="code">
algorithme troisièmeAngleTriangle(angle1, angle2 : réels)→ réel
    retourner 180 - (angle1 + angle2)
fin algorithme
          </paragraph>
          Traduisons cet algorithme en java en ajoutant le traitement des données en entrée et sortie (demande au clavier et affichage à l'écran) :
          <paragraph cssClass="java">
import java.util.Scanner;
public class Triangle{
    public static void main(String [] args) {
        Scanner clavier = new Scanner(System.in);
        double angle1 = clavier.nextDouble();
        double angle2 = clavier.nextDouble();
        double angle3 = troisiemeAngleTriangle(angle1, angle2);
        System.out.println(angle3);
    }    
    
    public static double troisiemeAngleTriangle(double angle1, double angle2) {
        return 180 - (angle1 + angle2);
    }
}
        </paragraph>
        Il nous reste à compiler <formatted style="input">javac Triangle.java</formatted> et à exécuter <formatted style="input">java Triangle</formatted> notre programme.
        </paragraph>
        
        <paragraph title="À vous">
        Écrivez les algorithmes et codez les programmes Java correspondant qui 
          <list listStyle="ordered">
            <item>dans 3 algorithmes/méthodes différent(e)s affiche respectivement  "*", "**", "***" .</item>
            <item>affiche le triangle 
            <paragraph>*</paragraph><paragraph>**</paragraph><paragraph>***</paragraph>
            </item>
            <item>calcule et retourne la surface d’un carré en recevant la valeur de son côté. Pour rappel, la surface du carré est la longueur du côté au carré.</item>
            <item>calcule et retourne la surface d’un rectangle en recevant les valeurs de sa longueur et sa largeur . Pour rappel, la surface du rectangle est la longueur multipliée par la largeur.</item>
            <item>calcule et retourne la surface d’un cercle en recevant la valeur de son rayon. Pour rappel, la surface du cercle est PI multiplié par la valeur du rayon au carré. (Pensez à aller voir la classe Math pour obtenir la valeur de PI ;))</item>
            <item>étant donné le prix unitaire d’un produit (hors TVA), le taux de TVA (en %) 
            et la quantité de produit vendue à un client, calcule et retourne le prix total à payer par ce client. 
            Pour rappel, le prix total est la quantité multipliée par le prix unitaire multiplié par (1 + le taux de tva)</item>
            <item>réalise la permutation du contenu de deux variables.</item>
            <item>calcule et retourne la somme des chiffres d’un nombre entier de 3 chiffres reçu en paramètre. Réflexion  : l’algorithme est-il aussi valide pour les entiers inférieurs à 100 ?</item>
            <item>étant donné un moment dans la journée donné par trois nombres reçus, à savoir, heure, minute et seconde, calcule le nombre de secondes écoulées depuis minuit.</item>
          </list>
        </paragraph>
      </act>
    </learningObject>
  </unit>
	
</lesson>
