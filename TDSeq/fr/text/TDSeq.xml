<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="../../../_templates/java/latex.xsl"?>
<lesson xmlns="http://www.elml.ch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.elml.ch ../../../_config/validate.xsd" 
	label="TDSeq" title="TD Séquentiel - Rappels de base">
	
	<entry>
		<paragraph>
			Ce TD a pour but de 
			<paragraph>
			    <!--multimedia src="../image/fs.jpeg" type="jpeg" /-->
        </paragraph>
		</paragraph>
	</entry>
	
	<!-- =========================================================== -->
	<unit label="Séquentiel" title="Algorithmes séquentiels">
	<!-- =========================================================== -->

    <entry>Revoyons ici les bases du pseudo-code et leur traduction en Java.</entry>
    
		<learningObject title="Le pseudo-code">
		<!-- ================================================ -->
		  <paragraph>
		    Le pseudo-code ou Langage de Description des Algorithmes (LDA en abrégé) est un langage
        formel et symbolique utilisant :
        <list listStyle="unordered">
			    <item>
            des noms symboliques destinés à représenter les objets sur lesquels s’effectuent des
            actions ;
          </item>
          <item>
            des opérateurs symboliques ou des mots-clés traduisant les opérations primitives
            exécutables par un exécutant donné ;
          </item>
          <item>
            des structures de contrôle types.
          </item>
        </list>
		  </paragraph>
		</learningObject>

	</unit>
		
	<!-- =================================================================== -->
	<unit label="VariablesEtTypes" title="Variables et types">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Nous savons que les opérations que l’ordinateur devra exécuter portent sur des éléments qui
        sont les <formatted style="bold">données</formatted> du problème.
      </paragraph>
      <paragraph>
        Lorsqu’on attribue un <formatted style="bold">nom</formatted> 
        et un <formatted style="bold">type</formatted> à ces données, on
        parle alors de <formatted style="bold">variables</formatted>. 
      </paragraph>
      <paragraph>
        Dans un algorithme, une variable conserve toujours son nom et
        son type, mais peut changer de <formatted style="bold">valeur</formatted>.
         <list listStyle="unordered">
			    <item>
            Le <formatted style="bold">nom</formatted> d’une variable permet de la caractériser et de la reconnaitre ;
          </item>
          <item>
            le <formatted style="bold">type</formatted> d’une variable décrit la nature de son contenu.
          </item>
        </list>
			</paragraph>
    </entry>
    
			<learningObject title="Les types autorisés en algo">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          Dans un premier temps, les seuls types utilisés sont :
          <list listStyle="unordered">
            <item><formatted style="code">entier</formatted> pour les nombres entiers ;</item>
            <item><formatted style="code">réel</formatted> pour les nombres réels ;</item>
            <item><formatted style="code">caractère</formatted> pour les différentes lettres et caractères
              (par exemple ceux qui apparaissent sur un clavier : ‘a’, ‘1’, ‘#’, etc.)</item>
            <item><formatted style="code">chaine</formatted> pour les variables contenant un ou plusieurs caractère(s) ou aucun (la chaine vide)
              (par exemple : "Bonjour", "Bonjour le monde", "a", "", etc.)</item>
            <item><formatted style="code">booléen</formatted> les variables de ce type 
            ne peuvent valoir que <formatted style="code">vrai</formatted> ou <formatted style="code">faux</formatted></item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Le type des données" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>une date du calendrier ? <gap answers="3 entiers,trois entiers,2 entiers 1 chaine,1 chaine 2 entiers">3 entiers</gap></item>  
									<item>un moment dans la journée ? <gap answers="3 entiers, trois entiers">3 entiers</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="1 réel,un réel, réel">1 réel</gap></item>  
									<item>votre nom ? <gap answers="une chaine,1 chaine, chaine">1 chaine</gap></item>  
									<item>vos initiales ?<gap answers="2 caractères,3 caractères">2 caractères</gap></item>  
									<item>votre adresse ? <gap answers="1 chaine">1 chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      
			<learningObject title="Les types équivalents en java">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          Les équivalents Java des types donnés en algo sont
          <list listStyle="unordered">
            <item><formatted style="code">int</formatted> pour le type <formatted style="code">entier</formatted> pour les nombres entiers ;</item>
            <item><formatted style="code">double</formatted> pour le type <formatted style="code">réel</formatted> pour les nombres réels ;</item>
            <item><formatted style="code">char</formatted> pour le type <formatted style="code">caractère</formatted> pour les différentes lettres et caractères</item>
            <item><formatted style="code">String</formatted> pour le type <formatted style="code">chaine</formatted> 
              pour les variables contenant un ou plusieurs caractère(s) ou aucun (la chaine vide)
            </item>
            <item><formatted style="code">boolean</formatted> pour le type <formatted style="code">booléen</formatted> les variables de ce type 
            ne peuvent valoir, en Java, que <formatted style="code">true</formatted> ou <formatted style="code">false</formatted></item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Les commandes de base" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>une date du calendrier ? <gap answers="3 entiers,trois entiers,2 entiers 1 chaine,1 chaine 2 entiers">3 entiers</gap></item>  
									<item>un moment dans la journée ? <gap answers="3 entiers, trois entiers">3 entiers</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="1 réel,un réel, réel">1 réel</gap></item>  
									<item>votre nom ? <gap answers="une chaine,1 chaine, chaine">1 chaine</gap></item>  
									<item>vos initiales ?<gap answers="2 caractères,3 caractères">2 caractères</gap></item>  
									<item>votre adresse ? <gap answers="1 chaine">1 chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      <learningObject title="Java est un langage fortement typé.">
			<!-- ================================================ -->
			  <clarify>
			  <paragraph>
			    Java est un langage fortement typé.
			  </paragraph>
        <paragraph>
          Toute donnée a un type. Quels types ?
          <list listStyle="unordered">
            <item><formatted style="code">primitifs prédéfinis : </formatted> entier, réel, booléen (logique) ;</item>
            <item><formatted style="code">références prédéfinis :</formatted> tableaux, String, . . . ;</item>
            <item><formatted style="code">références définis par le programmeur</formatted> </item>
          </list>
        </paragraph>
        
        <paragraph title="Les types primitifs" icon="important" />
        <paragraph>
			    <multimedia src="../image/primitifs.png" type="png" />
        </paragraph>
        
        <paragraph title="Les types primitifs numériques entiers" icon="important" />
        <paragraph>
          Les types primitifs numériques entiers sont
          <formatted style="code">byte</formatted>, <formatted style="code">short</formatted>, 
          <formatted style="code">int</formatted> et <formatted style="code">long</formatted> (<formatted style="code">char</formatted> sera vu à part),
          <list listStyle="unordered">
            <item> ce sont des nombres signés (en complément à 2)</item>
            <item> ils sont codés sur 
              <list listStyle="unordered">
                <item> 8-bit pour un <formatted style="code">byte</formatted> ;</item>
                <item> 16-bit pour un <formatted style="code">short</formatted> ;</item>
                <item> 32-bit pour un <formatted style="code">int</formatted> ;</item>
                <item> 64-bit pour un <formatted style="code">long</formatted> ;</item>
              </list>
            </item>
            <item> ils comprennent donc les valeurs :
              <list listStyle="unordered">
                <item> -128 à 127 pour un <formatted style="code">byte</formatted> ;</item>
                <item> -32768 à 32767 pour un <formatted style="code">short</formatted> ;</item>
                <item> -2147483648 à 2147483647 pour un <formatted style="code">int</formatted> ;</item>
                <item> -9223372036854775808 à 9223372036854775807 pour un <formatted style="code">long</formatted> ;</item>
              </list>
            </item>
          </list>
        </paragraph>
        
        <paragraph title="Les littéraux pour les types primitifs numériques entiers" icon="important" />
        <paragraph>
          Un <formatted style="bold">littéral</formatted>, c'est une notation pour représenter une valeur fixée directement dans un code  source.
        </paragraph>
        <paragraph>
          Un <formatted style="bold">littéral numérique décimal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres</item>
                <item>éventuellement séparés par<formatted style="input">_</formatted> pour la lisibilité</item>
                <item>suivi éventuellement du suffixe ( <formatted style="input">l</formatted> ou <formatted style="input">L</formatted>) 
                qui distingue un <formatted style="code">int</formatted> d’un <formatted style="code">long</formatted></item>
                <item>pas de <formatted style="code">byte</formatted> ou <formatted style="code">short</formatted>, 
                un littéral est <formatted style="code">int</formatted> (ou <formatted style="code">long</formatted>)</item>
              </list>
        </paragraph>
        
        <paragraph>
          Un <formatted style="bold">littéral numérique octal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres de 0 à 7</item>
                <item>précédé de 0.</item>
              </list>
        </paragraph>
        
        <paragraph>
          Un <formatted style="bold">littéral numérique hexadécimal</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres et lettres a,b,c,d,e,f (minuscules/majuscules)</item>
                <item>précédé de 0x ou 0X</item>
            </list>
          </paragraph>
          
          <paragraph>
          Un <formatted style="bold">littéral numérique binaire</formatted> est
            <list listStyle="unordered">
                <item>une suite de chiffres 0 et 1</item>
                <item>précédé de 0b ou 0B</item>
            </list>
          </paragraph>
          
          <paragraph>
          Par exemple, la quantité 100 de type <formatted style="code">int</formatted> peut s'écrire 
            <list listStyle="unordered">
                <item>100</item>
                <item>1_0_0</item>
                <item>0144</item>
                <item>01_44</item>
                <item>0x64</item>
                <item>0b110_0100</item>
              </list>
            </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="Les commandes de base" shuffle="yes">
						<fillInBlanks>
							<question> 
								Quel(s) type(s) de données utiliseriez-vous pour représenter :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>une date du calendrier ? <gap answers="3 entiers,trois entiers,2 entiers 1 chaine,1 chaine 2 entiers">3 entiers</gap></item>  
									<item>un moment dans la journée ? <gap answers="3 entiers, trois entiers">3 entiers</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="1 réel,un réel, réel">1 réel</gap></item>  
									<item>votre nom ? <gap answers="une chaine,1 chaine, chaine">1 chaine</gap></item>  
									<item>vos initiales ?<gap answers="2 caractères,3 caractères">2 caractères</gap></item>  
									<item>votre adresse ? <gap answers="1 chaine">1 chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
      
      
			<learningObject title="Déclaration de variables en algo">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          La <formatted style="bold">déclaration</formatted> d’une variable est l’instruction qui définit son <formatted style="bold">nom</formatted> 
          et son <formatted style="bold">type</formatted>.
        </paragraph>
        <paragraph>
          <formatted style="input">num1, num2 : entiers</formatted>
        </paragraph>
        <paragraph>
          L’ensemble des instructions de la forme <formatted style="input">variable1, variable2,. . . : type</formatted>
          forme la partie d’un algorithme nommée <formatted style="bold">déclaration des variables</formatted>. 
        </paragraph>
        <paragraph>
          La déclaration des informations apparaitra toujours en <formatted style="bold">début</formatted> d’algorithme, ou dans un bloc annexe appelé
          dictionnaire des variables ou encore dictionnaire des données.
        </paragraph>
        
        <paragraph title="Attention" icon="important" />
        <paragraph>
          Attention, lors de la déclaration d’une variable, <formatted style="bold">celle-ci n’a pas de valeur</formatted> ! 
          Nous verrons que c’est l’instruction d’affectation qui va servir à donner un contenu aux variables déclarées.
        </paragraph>
        </clarify>
      
			  <clarify>
			  <paragraph title="Comment nommer correctement une variable ?" icon="icon_question" />
        <paragraph>
          Le but est de trouver un nom qui soit suffisamment <formatted style="bold">court</formatted>, 
          tout en restant <formatted style="bold">explicite</formatted> et ne prêtant <formatted style="bold">pas à confusion</formatted>.
        </paragraph>
        <paragraph>
          Ainsi <formatted style="italic">num1</formatted> est plus approprié pour désigner le premier numérateur 
          que <formatted style="italic">zozo1</formatted>, <formatted style="italic">tintin</formatted>, <formatted style="italic">bidule</formatted>
          ou <formatted style="italic">premierNumérateur</formatted>. 
          De même, ne pas appeler <formatted style="italic">den</formatted> la variable représentant le numérateur.
        </paragraph>
        <paragraph>
          Il faut aussi tenir compte que les langages de programmation imposent certaines limitations
          (parfois différentes d’un langage à l’autre) ce qui peut nécessiter une modification du nom
          lors de la traduction.
        </paragraph>
        <paragraph>
          Voici quelques règles et limitations traditionnelles dans les langages de programmation :
          <list listStyle="unordered">
            <item>
            Un nom de variable est généralement une suite de caractères alphanumériques d’un
            seul tenant (pas de caractères blancs) et ne commençant jamais par un chiffre. Ainsi
            x1 est correct mais pas 1x.
            </item>
            <item>
            Pour donner un nom composé à une variable, on peut utiliser le « tiret bas » ou underscore 
            (par ex. premier_numérateur) mais on déconseille d’utiliser le signe « – » qui est
            plutôt réservé à la soustraction. Ainsi, dans la plupart des langages, premier-numérateur
            serait interprété comme la soustraction des variables premier et numérateur.
            </item>
            <item>
            Une alternative à l’utilisation du tiret bas pour l’écriture de noms de variables composés
            est la notation « chameau » (camelCase en anglais), qui consiste à mettre une majuscule
            au début des mots (généralement à partir du deuxième), par exemple premierNombre
            ou dateNaissance.
            </item>
            <item>
            Les indices et exposants sont proscrits.
            </item>
            <item>
            Les mots-clés du langage sont interdits (par exemple for, if, while pour Java et Cobol)
            et on déconseille d’utiliser les mots-clés du pseudo-code (tels que Lire, Afficher, pour. . .)
            </item>
            <item>
            Certains langages n’autorisent pas les caractères accentués (tels que à, ç, ê, ø, etc.)
            ou les lettres des alphabets non latins mais d’autres oui ; certains font la
            distinction entre les minuscules et majuscules, d’autres non. En algorithmique, nous
            admettons, dans les noms de variables les caractères accentués du français, par ex. :
            durée, intérêts, etc.
            </item>
          </list>
        </paragraph>
        </clarify>
      
        <act>
				<selfCheck title="Comment déclarer" shuffle="yes">
						<fillInBlanks>
							<question>
							  Quelle instruction permet de déclarer :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>le jour d'une date ?<gap answers="jour : entier">jours : entier</gap></item>  
									<item>l'heure d'un moment ? <gap answers="heure : entier">heure : entier</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="prix : réel">prix : réel</gap></item>  
									<item>votre nom ? <gap answers="nom : chaine">nom : chaine</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
	
			<learningObject title="Déclaration de variables en Java">
			<!-- ================================================ -->
			  <clarify>
        <paragraph>
          La <formatted style="bold">déclaration</formatted> d’une variable est l’instruction qui définit son <formatted style="bold">nom</formatted> 
          et son <formatted style="bold">type</formatted>.
        </paragraph>
        <paragraph>
          <formatted style="input">int num1;</formatted>
        </paragraph>
        <paragraph>
          L’ensemble des instructions de la forme <formatted style="input">type nom;</formatted>
          forme la <formatted style="bold">déclaration des variables</formatted>. 
        </paragraph>
        <paragraph>
          La déclaration des informations apparaitra en <formatted style="bold">début</formatted> de bloc.
        </paragraph>
        
        <paragraph title="Attention" icon="important" />
        <paragraph>
          Attention, comme en algo, lors de la déclaration d’une variable, <formatted style="bold">celle-ci n’a pas de valeur</formatted> ! 
          Nous verrons que c’est l’instruction d’affectation qui va servir à donner un contenu aux variables déclarées.
        </paragraph>
        </clarify>
      
			  <clarify>
			  <paragraph title="Comment nommer correctement une variable ?" icon="icon_question" />
        <paragraph>
          Le but est de trouver un nom qui soit suffisamment <formatted style="bold">court</formatted>, 
          tout en restant <formatted style="bold">explicite</formatted> et ne prêtant <formatted style="bold">pas à confusion</formatted>.
        </paragraph>
        <paragraph>
          Il faut aussi tenir compte des limitations du langage.
          <list listStyle="unordered">
            <item>
            Un nom de variable est généralement une suite de caractères alphanumériques d’un
            seul tenant (pas de caractères blancs) et ne commençant jamais par un chiffre. Ainsi
            x1 est correct mais pas 1x.
            </item>
            <item>
            un nom de variable ne peut comporter que des lettres, des chiffres, les caractères <formatted style="italic">_</formatted> et <formatted style="italic">$</formatted>.
            </item>
            <item>
            L’écriture de noms de variables composés
            est la notation « chameau » (camelCase en anglais), qui consiste à mettre une majuscule
            au début des mots (généralement à partir du deuxième), par exemple premierNombre
            ou dateNaissance.
            </item>
            <item>
            Pour donner un nom composé à une variable entièrement en majuscules, on peut utiliser le « tiret bas » ou underscore 
            (par ex. PREMIER_NUMERATEUR).
            </item>
            <item>
            Les mots-clés du langage sont interdits (par exemple for, if, while)
            </item>
          </list>
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="Comment déclarer" shuffle="yes">
						<fillInBlanks>
							<question>
							  Quelle instruction permet de déclarer :
							</question>
							<gapText> 
								<list listStyle="unordered">
									<item>le jour d'une date ?<gap answers="int jour;">int jour;</gap></item>  
									<item>l'heure d'un moment ? <gap answers="int heure;">int heure;</gap></item>  
									<item>le prix d’un produit en grande surface ?<gap answers="double prix;">double prix;</gap></item>  
									<item>votre nom ? <gap answers="String nom;">String nom;</gap></item>  
								</list>  
							</gapText>
							<solution></solution>
						</fillInBlanks>
					</selfCheck>
				</act>
      </learningObject>
	</unit>
	
	
	<!-- =================================================================== -->
	<unit label="OpérateursEtExpressions" title="Opérateurs et expressions">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Les <formatted style="bold">opérateurs</formatted> agissent sur les <formatted style="bold">variables</formatted> 
				et les <formatted style="bold">constantes</formatted> pour former des <formatted style="bold">expressions</formatted>. 
      </paragraph>
      <paragraph>
				Une expression est donc une combinaison cohérente de variables, de constantes et d’opérateurs,
				éventuellement accompagnés de parenthèses.
			</paragraph>
    </entry>
    
			<learningObject title="Les opérateurs arithmétiques élémentaires en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont les opérateurs binaires bien connus :
          <list listStyle="unordered">
            <item><formatted style="code">+</formatted> addition</item>
            <item><formatted style="code">-</formatted> soustraction</item>
            <item><formatted style="code">*</formatted> multiplication</item>
            <item><formatted style="code">/</formatted> division réelle</item>
          </list>
          Ils agissent sur des variables ou expressions à valeurs entières ou réelles. 
        </paragraph>
        <paragraph>
          Plusieurs opérateurs peuvent être utilisés pour former des expressions plus ou moins complexes, 
          en tenant compte des règles de calcul habituelles, notamment la priorité de la multiplication et de la division
          sur l’addition et la soustraction. 
        </paragraph>
        <paragraph>
          Il est aussi permis d’utiliser des parenthèses, par exemple <formatted style="input">a – (b + c * d)/x</formatted>. 
        </paragraph>
        <paragraph>
          Tout emploi de la division devra être accompagné d’une réflexion sur la
          valeur du dénominateur, une division par 0 entrainant toujours l’arrêt d’un algorithme.
        </paragraph>
        </clarify>
      </learningObject>
      
      
			<learningObject title="Les opérateurs arithmétiques élémentaires en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont les opérateurs binaires bien connus :
          <list listStyle="unordered">
            <item><formatted style="code">+</formatted> addition</item>
            <item><formatted style="code">-</formatted> soustraction</item>
            <item><formatted style="code">*</formatted> multiplication</item>
            <item><formatted style="code">/</formatted> division réelle si au moins un des deux opérandes est réel</item>
            <item><formatted style="code">/</formatted> division entière si les deux opérandes sont entiers</item>
          </list>
          Ils agissent sur des variables ou expressions à valeurs entières ou réelles. 
        </paragraph>
        <paragraph>
          Plusieurs opérateurs peuvent être utilisés pour former des expressions plus ou moins complexes, 
          en tenant compte des règles de calcul habituelles, notamment la priorité de la multiplication et de la division
          sur l’addition et la soustraction. 
        </paragraph>
        <paragraph>
          Il est aussi permis d’utiliser des parenthèses, par exemple <formatted style="input">a – (b + c * d)/x</formatted>. 
        </paragraph>
        <paragraph>
          Tout emploi de la division devra être accompagné d’une réflexion sur la
          valeur du dénominateur, une division par 0 entrainant un arrêt du programme.
        </paragraph>
        </clarify>
      </learningObject>
      
			<learningObject title="Les opérateurs DIV et MOD en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont deux opérateurs très importants qui ne peuvent s’utiliser qu’avec des variables entières :
          <list listStyle="unordered">
            <item><formatted style="code">DIV</formatted> division entière</item>
            <item><formatted style="code">MOD</formatted> reste de la division entière</item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
			<learningObject title="Les opérateurs DIV et MOD en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          Ce sont deux opérateurs très importants qui ne peuvent s’utiliser qu’avec des variables entières :
          <list listStyle="unordered">
            <item><formatted style="code">/</formatted> division entière si les deux opérandes sont entiers</item>
            <item><formatted style="code">%</formatted> reste de la division entière</item>
          </list>
        </paragraph>
        </clarify>
      </learningObject>
      
      <learningObject title="Les fonctions mathématiques complexes en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          <list listStyle="unordered">
            <item>L’élévation à la puissance sera notée ** ou ˆ . </item>
            <item>Pour la racine carrée d’une variable x nous écrirons √x . Attention, pour ce dernier, de veiller à ne l’utiliser qu’avec un radicant positif !
            Exemple : <formatted style="code">(−b +√(b ∗ ∗2 − 4 ∗ a ∗ c))/(2 ∗ a)</formatted></item>
            <item> À votre avis, pourquoi ne pas avoir écrit « 4ac » et « 2a » ?</item>
            <item>Si nécessaire, on se permettra d’utiliser les autres fonctions mathématiques sous leur forme
            la plus courante dans la plupart des langages de programmation (exemples : sin(x), tan(x), log(x), exp(x). . .)</item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    
    <learningObject title="Les fonctions mathématiques complexes en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
        L'essentiel des fonctions mathématiques se trouvent dans la classe Math.
          <list listStyle="unordered">
            <item>Math.pow(a,b) est l'élévation à la puissance aˆb</item>
            <item>Math.sqrt(x) est la racine carrée d’une variable x, √x . Attention, pour ce dernier, de veiller à ne l’utiliser qu’avec un radicant positif !</item>
            <item>Si nécessaire,les autres fonctions mathématiques Math.sin(x), Math.tan(x), Math.log(x), Math.exp(x). . .)</item>
          </list>
        </paragraph>
      </clarify>
    </learningObject>
    </unit>
    
    
	<!-- =================================================================== -->
	<unit label="Affectation" title="L’affectation d’une valeur à une variable">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Cette opération est probablement l’opération la plus importante. En effet, une variable ne
        prend son sens réel que si elle reçoit à un moment donné une valeur. Il y a deux moyens de
        donner une valeur à une variable.
      </paragraph>
    </entry>
    
			<learningObject title="Affectation interne en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation interne</formatted> lorsque la valeur d’une variable est « calculée » par l’exécutant
          de l’algorithme lui-même à partir de données qu’il connait déjà :
          <formatted style="input">nomVariable ← expression</formatted>
          Rappelons qu’une expression est une combinaison de variables et d’opérateurs. <formatted style="bold">L’expression a une valeur</formatted>.
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="" shuffle="yes">
					<multipleChoice>
						<question>Les exemples d’affectation sont-ils corrects ?
						</question>
						<answer feedback="" correct="yes">somme ← nombre1 + nombre2</answer>
						<answer feedback="" correct="yes">denRes ← den1 * den2</answer>
						<answer feedback="" correct="yes">cpt ← cpt + 1</answer>
						<answer feedback="" correct="yes">delta ← b**2 – 4*a*c</answer>
						<answer feedback="" correct="yes">maChaine ← "Bonjour"</answer>
						<answer feedback="" correct="yes">test ← a = b</answer>
						<answer feedback="" correct="no">somme + 1 ← 3</answer>
						<answer feedback="" correct="no">somme ← 3n</answer>
					</multipleChoice>
				</selfCheck>
				</act>
				<paragraph>
				Remarques
				<list listStyle="unordered">
            <item>
              Il est de règle que le résultat de l’expression à droite du signe d’affectation (←) soit de
              même type que la variable à sa gauche. On tolère certaines exceptions :
              <list listStyle="unordered">
                <item>
                  varEntière ← varRéelle : dans ce cas le contenu de la variable sera la valeur tronquée de l’expression réelle. 
                  Par exemple si « nb » est une variable de type entier,
                  son contenu après l’instruction <formatted style="input">nb ← 15/4 »</formatted> sera 3
                </item>
                <item>varRéelle ← varEntière : ici, il n’y a pas de perte de valeur.</item>
                <item>varChaine ← varCaractère : équivalent à varChaine ← chaine(varCaractère).</item>
                <item>Le contraire n’est évidemment pas accepté.</item>
              </list>
            </item>
            <item>
            Seules les variables déclarées peuvent être affectées, que ce soit par l’affectation externe
            ou interne !
            </item>
            <item>
            Nous ne mélangerons pas la déclaration d’une variable et son affectation interne dans
            une même ligne de code, donc pas d’instructions hybrides du genre x ← 2 : entier ou
            encore x : entier(0).
            </item>
            <item>
            Pour l’affectation interne, toutes les variables apparaissant dans l’expression doivent
            avoir été affectées préalablement. Le contraire provoquerait un arrêt de l’algorithme.
            </item>
          </list>
        </paragraph>
      </learningObject>
      
      <learningObject title="Affectation interne en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation interne</formatted> lorsque la valeur d’une variable est « calculée » par l’exécutant
          de l’algorithme lui-même à partir de données qu’il connait déjà :
          <formatted style="input">nomVariable = expression;</formatted>
          Rappelons qu’une expression est une combinaison de variables et d’opérateurs. <formatted style="bold">L’expression a une valeur</formatted>.
        </paragraph>
        </clarify>
        
        <act>
				<selfCheck title="" shuffle="yes">
					<multipleChoice>
						<question>Les exemples d’affectation sont-ils corrects ?
						</question>
						<answer feedback="" correct="yes">somme = nombre1 + nombre2;</answer>
						<answer feedback="" correct="yes">denRes = den1 * den2;</answer>
						<answer feedback="" correct="yes">cpt = cpt + 1;</answer>
						<answer feedback="" correct="yes">delta = b**2 – 4*a*c;</answer>
						<answer feedback="" correct="yes">maChaine = "Bonjour";</answer>
						<answer feedback="" correct="no">somme + 1 = 3;</answer>
						<answer feedback="" correct="no">somme = 3n;</answer>
					</multipleChoice>
				</selfCheck>
				</act>
      </learningObject>
      
			<learningObject title="Affectation externe en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation externe</formatted> lorsque la valeur à affecter à une variable
           est donnée par l’utilisateur qui la communique à l’exécutant quand celui-ci le lui demande : cette valeur est
          donc externe à la procédure (l’ordinateur ne peut la deviner lui-même !)
        </paragraph>
        <paragraph>
          L’affectation externe est donc la primitive qui permet de recevoir de l’utilisateur, au moment
          où l’algorithme se déroule, une ou plusieurs valeur(s) et de les affecter à des variables en
          mémoire. 
        </paragraph>
        <paragraph>
          Nous noterons :
          <formatted style="input">lire liste_de_variables_à_lire</formatted>
        </paragraph>
        <paragraph>
          Exemples
          <formatted style="input">lire nombre1, nombre2</formatted>
          <formatted style="input">lire num1, den1, num2, den2</formatted>
        </paragraph>
        <paragraph>
          L’exécution de cette instruction provoque une pause dans le déroulement de l’algorithme ;
          l’exécutant demande alors à l’utilisateur les valeurs des variables à lire. Ces valeurs viennent
          donc de l’extérieur ; une fois introduites dans le système, elles sont affectées aux variables
          concernées et l’algorithme peut reprendre son cours. Les possibilités d’introduction de don-
          nées sont nombreuses : citons par exemple l’encodage de données au clavier, un clic de souris,
          le toucher d’un écran tactile, des données provenant d’un fichier, etc.
        </paragraph>
        </clarify>
        </learningObject>
        
        
			<learningObject title="Affectation externe en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          On parle d’<formatted style="bold">affectation externe</formatted> lorsque la valeur à affecter à une variable
           est donnée par l’utilisateur qui la communique à l’exécutant quand celui-ci le lui demande : cette valeur est
          donc externe à la procédure (l’ordinateur ne peut la deviner lui-même !)
        </paragraph>
        <paragraph>
          L’affectation externe est donc la primitive qui permet de recevoir de l’utilisateur, au moment
          où l’algorithme se déroule, une ou plusieurs valeur(s) et de les affecter à des variables en
          mémoire. 
        </paragraph>
        <paragraph>
          Nous noterons :
          </paragraph>
          <paragraph cssClass="java">
 import java. util .Scanner;
// ...
Scanner clavier = new Scanner(System.in);
// ...
int nombre1 = clavier. nextInt ();
				</paragraph>
        <paragraph>
          Les différentes lectures possibles sont :
          <list listStyle="unordered">
            <item>pour un entier : clavier.nextInt();</item>
            <item>pour un réel : clavier.nextDouble();</item>
            <item>pour un booléen : clavier.nextBoolean();</item>
            <item>pour un mot : clavier.next()</item>
            <item>pour une ligne : clavier.nextLine();</item>
            <item>pour un caractère : clavier.next.charAt(0);</item>
          </list>
        </paragraph>
        </clarify>
        </learningObject>
        
        <learningObject title="Communication des résultats en algo">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          L’instruction de communication des résultats consiste à donner à l’extérieur (donc à l’utilisateur) 
          la valeur d’un résultat calculé au cours de l’exécution de l’algorithme.
        </paragraph>
        <paragraph>
          Nous noterons :
          <formatted style="input">afficher expression ou liste de variables séparées par des virgules</formatted>
          qui signifie que la valeur d’une expression (ou celles des différentes variables mentionnées) 
          sera fournie à l’utilisateur (par exemple par un affichage à l’écran ou par impression sur
          listing via l’imprimante, etc.).
          </paragraph>
          <paragraph>
          Remarques :
          <list listStyle="unordered">
            <item>
              Ce ne serait pas une erreur fondamentale de remplacer lire par recevoir ou afficher
              par écrire. Il n’y a évidemment pas de confusion possible à partir du moment où l’on
              sait qu’il s’agit de primitives d’échange entre l’extérieur et l’ordinateur exécutant la
              procédure, mais par principe, il est conseillé d’utiliser une syntaxe commune et limitée
              à un petit nombre de mots-clés.
            </item>
            <item>
              Comme pour l’affectation interne, on ne peut afficher que des expressions dont les
              variables qui la composent ont été affectées préalablement.
            </item>
          </list>
          </paragraph>
        </clarify>
        </learningObject>
        
        <learningObject title="Communication des résultats en Java">
			<!-- ============================================================ -->
			  <clarify>
        <paragraph>
          L’affichage de la valeur d'une variable <formatted style="input">var</formatted>  est donnée par l'instruction
          </paragraph>
          <paragraph cssClass="java">
 System.out.println (var);
				</paragraph>
        <paragraph>
          Si nous voulons précéder l'affichage de la valeur d'une variable <formatted style="input">var</formatted>  par un message, 
          nous utiliserons l'instruction
        </paragraph>
        <paragraph cssClass="java">
 System.out.println ("La variable var vaut " + var);
				</paragraph>
        </clarify>
        </learningObject>
    </unit>
      
	
	<!--metadata>
		<organisation level="1ère année" module="Laboratoires Java">
			<creationPosition><posNumber>1</posNumber></creationPosition>
		</organisation>
		<prerequisites><preReqItem label="none"/></prerequisites>
		<keywords><keywordItem>Java</keywordItem><keywordItem>Linux</keywordItem></keywords>
		<technical>
			<technicalRequirement>
				<type>Browser</type>
				<name>any</name>
				<minimumVersion>unknown</minimumVersion>
			</technicalRequirement>
		</technical>
		<lessonInfo>
			<language language="fr" derived="no"/>
			<lifecycle>
				<version>2013 - 2014</version>
				<contribute>
<person name="BEJ" />  <person name="CLG" />  <person name="CLR" />  <person name="DNA" />  <person name="MCD" />  <person name="NPX" />  <person name="PBT" />  <person name="SRV" /> 
				</contribute>
			</lifecycle>
			<educational><typicalLearningTime><time/></typicalLearningTime></educational>
		</lessonInfo>
		<rights>
			<cost>no</cost>
			<copyright>Distribué sous licence Creative Commons Paternité - Partage à l'Identique 2.0 Belgique</copyright>
			<copyrightURL>http://creativecommons.org/licenses/by-sa/2.0/be/</copyrightURL>
		</rights>
	</metadata-->

</lesson>
