<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="../../../_templates/java/latex.xsl"?>
<lesson xmlns="http://www.elml.ch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.elml.ch ../../../_config/validate.xsd" 
	label="TDTableau" title="TD Tableaux">
	
	<entry>
		<paragraph>
			Voyons ici les tableaux, une structure qui peut contenir plusieurs exemplaires de données similaires.
    </paragraph>
	</entry>
	
	<!-- =========================================================== -->
	<unit label="Tableaux" title="Les tableaux">
	<!-- =========================================================== -->

    <entry>
      <paragraph>
        Un <formatted style="bold">tableau</formatted> est une suite d’éléments de même type 
        portant tous le même nom mais se distinguant les uns des autres par un indice.
      </paragraph>
      <paragraph>
        L’<formatted style="bold">indice</formatted> est un entier donnant la position d’un élément dans la suite. 
        Cet indice varie entre la position du premier élément et la position du dernier élément, 
        ces positions correspondant aux <formatted style="bold">bornes de l’indice</formatted>. <newLine/>
        Notons qu’il n’y a pas de « trou » : tous les éléments existent entre le premier et le dernier indice.
      </paragraph>
      <paragraph>
        La <formatted style="bold">taille d’un tableau</formatted> est le nombre (strictement positif) de ses éléments. <newLine/>
        Attention ! la taille d’un tableau ne peut pas être modifiée pendant son utilisation.
      </paragraph>
      <paragraph>
        Souvent on utilise un tableau plus grand que le nombre utile de ses éléments. 
        Seule une partie du tableau est utilisée. 
        On parle alors de <formatted style="bold">taille physique (la taille maximale du tableau)</formatted> et
        de <formatted style="bold">taille logique (le nombre d’éléments effectivement utilisés)</formatted>.
		</paragraph>
    </entry>
    
		<learningObject title="Notation en algo">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
        Pour <formatted style="bold">déclarer un tableau</formatted>, on écrit :
      </paragraph>
		  <paragraph cssClass="code">
nomTableau : tableau de <formatted style="italic">taille</formatted> TypeÉlément
      </paragraph>
      <paragraph>
        où <formatted style="code">TypeÉlément</formatted> est le type des éléments 
        que l’on trouvera dans le tableau. Les éléments sont
        d’un des types élémentaires vus précédemment 
        (<formatted style="code">entier</formatted>, <formatted style="code">réel</formatted>, 
        <formatted style="code">booléen</formatted>, <formatted style="code">chaine</formatted>, 
        <formatted style="code">caractère</formatted>) ou encore des variables structurées. 
      </paragraph>
      <paragraph>
        À ce propos, remarquons aussi qu’un tableau peut être un
        champ d’une structure. D’autres possibilités apparaitront lors de l’étude de l’orienté objet.
      </paragraph>
      <paragraph>
       Une fois un tableau déclaré, <formatted style="bold">seuls les éléments d’indice
        compris entre 0 et taille-1 peuvent être utilisés</formatted>. 
      </paragraph>
      <paragraph>
        Par exemple, si on déclare :
      </paragraph>
      <paragraph cssClass="code">
        tabEntiers : tableau de 100 entiers
      </paragraph>
      <paragraph>
        Il est interdit d’utiliser tabEntiers[-1] ou tabEntiers[100]. De plus, chaque élément tabEntiers[i]
        (avec 0 ≤ i ≤ 99) doit être manié avec la même précaution qu’une variable simple, c’est-à-
        dire qu’on ne peut utiliser un élément du tableau qui n’aurait pas été préalablement affecté
        ou initialisé.
      </paragraph>
      <paragraph>
        N.B. : Il n’est pas interdit de prendre autre chose que 0 pour la borne inférieure ou même d’utiliser des
        bornes négatives (par exemple : tabTempératures : tableau [-20 à 50] de réels).
        En Java, un tableau est défini par sa taille n et les bornes sont automatiquement 0 et n − 1.
        Ce n’est pas le cas en algorithmique où on a plus de liberté dans le choix des bornes
      </paragraph>
    </clarify>
    
    <look>
      <paragraph cssClass="code">
// Calcule et affiche la quantité vendue de 10 produits.
algorithme statistiquesVentesAvecTableau()
    cpt : tableau de 10 entiers
    i, numéroProduit, quantité : entiers
    
    pour i de 0 à 9 faire
      cpt[i] ← 0
    fin pour
    
    afficher "Introduisez le numéro du produit :"
    demander numéroProduit
    tant que numéroProduit ≥ 0 et numéroProduit ≤ 9 faire
      afficher "Introduisez la quantité vendue :"
      demander quantité
      cpt[numéroProduit] ← cpt[numéroProduit] + quantité
      afficher "Introduisez le numéro du produit :"
      demander numéroProduit
    fin tant que
    
    pour i de 0 à 9 faire
      afficher "quantité vendue de produit ", i, " : ", cpt[i]
    fin pour
fin algorithme
      </paragraph>
    </look>
		</learningObject>
		
		<learningObject title="Déclaration et création en Java">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Nous présentons ici une vue simplifiée  des tableaux en Java afin de coller
        au cours d’algorithmique.
      </paragraph>
      <paragraph>
        Nous aurons l’occasion d’être plus précis en DEV2.
      </paragraph>
      <paragraph>
        Pour rappel, il est nécessaire de manipuler plusieurs variables similaires
        auxquelles on accède par un indice :
      </paragraph>
      <paragraph>
        <multimedia src="../image/tabPres.png" type="png" />
      </paragraph>
      <paragraph>
        Contrairement à algo où on peut avoir le choix des valeurs des bornes pour les indices, 
        en Java, les indices varient toujours de <formatted style="code">0</formatted> à <formatted style="code">taille du tableau - 1</formatted>.
      </paragraph>
      <paragraph>0 est l’indice de départ.</paragraph>
      <paragraph title="Déclaration et création : 2 étapes">
        En Java, l'étape de création est séparée de l'étape de déclaration. <newLine/>
        En effet, l'étape de déclaration réserve un emplacement mémoire sur la pile qui contiendra une adresse 
        où trouver la valeur des éléments du tableau. <newLine/>
        La création connaitra la taille du tableau, le créera sur le tas et remplira l'adresse sur la pile.
      </paragraph>
      <paragraph>
        <multimedia src="../image/reference.png" type="png" />
      </paragraph>
      <paragraph title="Déclaration">
        Pour déclarer un tableau : 
      </paragraph>
      <paragraph cssClass="code">
Type[] identifier
      </paragraph>
      <paragraph>
        Par exemple :<newLine/>
        <formatted style="code">int []</formatted> est le type tableau d’entiers<newLine/>
        <formatted style="code">String []</formatted> est le type tableau de chaines de caractères
      </paragraph>
      <paragraph cssClass="code">
int [] cotes ;
String [] noms;
      </paragraph>
      <paragraph title="Création">
        Pour créer un tableau : 
      </paragraph>
      <paragraph cssClass="code">
identifier = new Type[taille]
      </paragraph>
      <paragraph>
        Par exemple :<newLine/>
        <formatted style="code">new int[3]</formatted><newLine/>
        <formatted style="code">new String[taille]</formatted> où <formatted style="code">taille</formatted> est défini
      </paragraph>
      <paragraph cssClass="code">
int [] entiers ; // déclaration
entiers = new int[3]; // création
      </paragraph>
      <paragraph>
        La déclaration et la création peuvent être combinées
      </paragraph>
      <paragraph cssClass="code">
int [] entiers = new int[3];
      </paragraph>
      <paragraph title="Initialisation">
        Par défaut, les éléments sont initialisés à 0 (numériques) ou false (booléens).
        Ce ne sont pas forcément les valeurs initiales que nous désirons. Pour changer ça :
      </paragraph>
      <paragraph cssClass="code">
identifier = new Type[] {x, x}
      </paragraph>
      <paragraph>
        Par exemple :<newLine/>
        <formatted style="code">new int[] {42, 17, -5}</formatted><newLine/>
        <formatted style="code">new String[] {"foo", "bar"}</formatted>
      </paragraph>
      <paragraph cssClass="code">
int [] entiers = new int[] {0x2A, 021, −5};
String [] noms = new String[] {" Victoria ", "Melanie", "Melanie", "Emma", "Geri"};
double[] réels ;
réels = new double[] {4.2, −1};
      </paragraph>
      <paragraph title="Cas particulier : déclaration, création et initialisation">
        On peut déclarer le tableau, le créer et l'initialiser en une seule étape, en donnant ses valeurs :
      </paragraph>
      <paragraph cssClass="code">
int [] entiers = {0x2A, 021, −5};
double[] pseudoRéels = {4.5, 1E−4, −4.12, Math.PI};

// Mais si sur 2 lignes :
double[] réels ;
réels = {4.2, −1}; // FAUX
      </paragraph>
      <paragraph title="Accès aux éléments">
      <list listStyle="ordered">
          <item>0 est l’indice de départ</item>
          <item>les indices varient de 0 à taille du tableau - 1</item>
          <item>la taille du tableau est son nombre d’éléments</item>
        </list>
      </paragraph>
      <paragraph cssClass="code">
int [] entiers = {3, 14, 15};
int entier = entiers [2]; // entier vaut 15
entiers [1] = 85;
entier = 0;
entier = entiers [entier +1]; // entier vaut 85
      </paragraph>
    </clarify>
    <look>
      <paragraph>Par exemple :</paragraph>
      <paragraph cssClass="code">
<![CDATA[
package be.heb.esi.lg1.tutorials.tableaux;

public class InitialisationTableau {
    public static void main(String [] args) {
      int [] entiers = new int[10];
      for(int i = 0; i < 10; i++) {
        entiers [ i ] = i;
      }
    }
}]]></paragraph>
    </look>
    </learningObject>

    <learningObject title="Taille logique et physique">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Parfois, on connait la taille d’un tableau lorsqu’on écrit l’algorithme (par exemple s’il s’agit
        de retenir les ventes pour les douze mois de l’année) mais ce n’est pas toujours le cas (par
        exemple, connait-on le nombre de produits vendus par le magasin ?).
		  </paragraph>
		  <paragraph>
		    Si cette taille n’est pas connue, une possibilité est
        d’attribuer au tableau une taille maximale (sa taille physique) et de retenir dans une
        variable le nombre réel de cases utilisées (sa taille logique).
		  </paragraph>
    </clarify>
    
    <look>
      <paragraph cssClass="code">
<![CDATA[// Calcule et affiche la quantité vendue de x produits.
algorithme statistiquesVentes()
    cpt : tableau de 1000 entiers
    i, numéroProduit, quantité : entiers
    nbArticles : entier
    
    demander nbArticles
    pour i de 0 à nbArticles-1 faire
      cpt[i] ← 0
    fin pour
    
    afficher "Introduisez le numéro du produit :"
    demander numéroProduit
    tant que numéroProduit ≥ 0 ET numéroProduit < nbArticles faire
      afficher "Introduisez la quantité vendue :"
      demander quantité
      cpt[numéroProduit] ← cpt[numéroProduit] + quantité
      afficher "Introduisez le numéro du produit :"
      demander numéroProduit
    fin tant que
    
    pour i de 0 à nbArticles-1 faire
      afficher "quantité vendue de produit ", i, " : ", cpt[i]
    fin pour
fin algorithme
]]></paragraph>
    </look>
    
  </learningObject>
  
  <learningObject title="Taille d'un tableau en Java">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    En Java, un tableau connait sa taille
      </paragraph>
      <paragraph cssClass="code">
identifier.length
      </paragraph>
      <paragraph cssClass="code">
int [] entiers = {4, 5, 6};
int taille = entiers.length ;
System.out.println (taille); // écrit 3
      </paragraph>
    </clarify>
    <look>
      <paragraph>Par exemple : </paragraph>
      <paragraph cssClass="code">
<![CDATA[package be.heb.esi.lg1.tutorials.tableaux ;

public class SimpleParcoursAscendant {
    public static void main(String [] args){
      int [] entiers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
      for(int i = 0; i < entiers.length ; i = i + 1) {
        System.out.println (entiers [i]);
      }
    }
}]]>
      </paragraph>
      <paragraph>ou encore</paragraph>
      <paragraph cssClass="code">
<![CDATA[package be.heb.esi.lg1.tutorials.tableaux ;

public class SimpleParcoursDescendant {
    public static void main(String [] args){
      int [] entiers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
      for(int i = entiers.length − 1; i >= 0; i = i−1) {
        System.out.println (entiers [i]);
      }
    }
}]]>
      </paragraph>
    </look>
    </learningObject>

		<learningObject title="Tableau et paramètres d'algorithme">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>
		    Un tableau peut être passé en paramètre à un algorithme mais qu’en est-il de sa taille ? Il
        serait utile de pouvoir appeler le même algorithme avec des tableaux de tailles différentes. Pour
        permettre cela, la taille du tableau reçu en paramètre est déclarée avec une variable (qui
        peut être considérée comme un paramètre entrant).
		  </paragraph>
		  <paragraph>
		    Par exemple :
		  </paragraph>
		  <paragraph cssClass="code">
algorithme afficherTaille(tabEntier↓ : tableau de n entiers)
    afficher "J’ai reçu un tableau de ", n, " éléments".
fin algorithme
      </paragraph>
		  <paragraph>
        Ce <formatted style="code">n</formatted> va prendre la taille précise du tableau utilisé à chaque appel
        et peut être utilisé dans le corps de l'algorithme. Bien sûr il s’agit là de la 
        <formatted style="bold">taille physique</formatted> du tableau. 
      </paragraph>
      <paragraph>
        Si une partie seulement du tableau doit être traitée, il convient de <formatted style="bold">passer également
        la taille logique en paramètre</formatted>.
      </paragraph>
		  <paragraph>Par exemple :</paragraph>
      <paragraph cssClass="code">
algorithme afficherTailles(tabEntiers↓ : tableau de n entiers, tailleLogique : entier)
    afficher "J’ai reçu un tableau rempli de ", tailleLogique, " éléments "
    afficher "sur ", n, " éléments au total."
fin algorithme
      </paragraph>
      <paragraph>
        Un algorithme peut retourner un tableau.
      </paragraph>
      <paragraph cssClass="code">
// Crée un tableau statique d’entiers de taille 10, l’initialise à 0 et le retourne.
algorithme créerTableau() → tableau de 10 entiers
    tab : tableau de 10 entiers
    i : entier
    pour i de 0 à 9 faire
      tab[i] ← 0
    fin pour
    retourner tab
fin algorithme

algorithme principalAppelTableau()
    entiers : tableau de 10 entiers
    i : entier
    entiers ← créerTableau()
    pour i de 0 à 9 faire
      afficher entiers[i]
    fin pour
fin algorithme
      </paragraph>
      <paragraph>
        Attention, il n'est pas possible de demander ou d'afficher un tableau en une seule instruction ; il faut des
        instructions de lecture ou d’affichage individuelles pour chacun de ses éléments.
      </paragraph>
    </clarify>
    </learningObject>
    
    <learningObject title="Tableau et paramètres de méthodes">
		<!-- ================================================ -->
		<clarify>
		  <paragraph>Un tableau peut être un paramètre d’une méthode.</paragraph>
		  <paragraph>Par exemple :</paragraph>
		  <paragraph cssClass="code">
<![CDATA[public static void afficher ( int [] entiers ) {
    for(int i = 0; i < entiers.length ; i ++) {
      System.out.println (entiers [i]);
    }
}]]></paragraph>
      <paragraph>L’appel pourrait être</paragraph>
      <paragraph cssClass="code">
int [] cotes = {12, 8, 10, 14, 9};
afficher ( cotes );
      </paragraph>
      <paragraph title="Passage de paramètre par valeur">
        En Java, passage de paramètre par valeur.
        Pour un tableau, cela signifie que l’on ne peut pas
        modifier le tableau dans son ensemble mais que
        l’on pourra modifier ses éléments.
      </paragraph>
      <paragraph>Par exemple :</paragraph>
		  <paragraph cssClass="code">
<![CDATA[public static void remplir ( int [] entiers , int val ) {
    for(int i = 0; i < entiers.length ; i ++) {
      entiers [ i ] = val;
    }
}]]></paragraph>
      <paragraph>L’appel pourrait être</paragraph>
      <paragraph cssClass="code">
int [] cotes = new int[16]; // Ne pas oublier de le créer !
remplir ( cotes , 20 );
      </paragraph>
      <paragraph>MAIS :</paragraph>
		  <paragraph cssClass="code">
<![CDATA[public static void méthodeFausse( double[] réels ) {
    double[] réelsDePassage = {4.2, −7, Math.PI};
    réels = réelsDePassage; // INUTILE
}]]></paragraph>
      <paragraph>
        Quel que soit l’appel, le tableau que l’on passe en
        paramètre ne sera pas modifié.
      </paragraph>
      
      <paragraph title="Un tableau peut être une valeur de retour">
      </paragraph>
      <paragraph>Par exemple :</paragraph>
		  <paragraph cssClass="code">
<![CDATA[ppublic static int [] créer ( int taille , int val ) {
    int [] entiers = new int[ taille ];
    for(int i = 0; i < taille ; i ++) {
      entiers [ i ] = val;
    }
    return entiers ;
}]]></paragraph>
      <paragraph>L’appel pourrait être</paragraph>
      <paragraph cssClass="code">
int [] cotes = créer(16, 20);
      </paragraph>
    </clarify>
    </learningObject>
		
    <learningObject title="Parcours d’un tableau à une dimension.">
		<!-- ================================================== -->
		<clarify>
		  <paragraph>
		    Soit le tableau <formatted style="code">tab</formatted> déclaré ainsi
		  </paragraph>
		  <paragraph cssClass="code">
tab : tableau de n T  // où n est la taille du tableau et T est un type quelconque
      </paragraph>
      <paragraph>Envisageons d’abord le parcours complet et voyons ensuite les parcours avec arrêt prématuré.</paragraph>
		  <paragraph title="Parcours complet.">
		    Pour parcourir complètement un tableau, on peut utiliser la boucle 
		    <formatted style="code">pour</formatted> comme dans
        l’algorithme suivant où « traiter » va dépendre du problème concret posé : afficher, modifier,
        sommer, . . .
      </paragraph>
		  <paragraph cssClass="code">
// Parcours complet d’un tableau via une boucle pour
// Les déclarations sont omises pour ne pas alourdir les algorithmes.
pour i de 0 à n-1 faire
    traiter tab[i]
fin pour
      </paragraph>
      <paragraph title="Parcours avec sortie prématurée.">
        Parfois, on ne doit pas forcément parcourir le tableau jusqu’au bout mais on pourra s’arrêter
        prématurément si une certaine condition est remplie. Par exemple :
        <list listStyle="ordered">
          <item>on cherche la présence d’un élément et on vient de le trouver ;</item>
          <item>on vérifie qu’il n’y a pas de 0 et on vient d’en trouver un.</item>
        </list>
        La première étape est de transformer le <formatted style="code">pour</formatted> 
        en <formatted style="code">tant que</formatted> ce qui donne l’algorithme
      </paragraph>
		  <paragraph  cssClass="code">
// Parcours complet d’un tableau via une boucle tant-que
i ← 0
tant que i ≤ n-1 faire
    traiter tab[i]
    i ← i+1
fin tant que
		  </paragraph>
		  <paragraph>
		    On peut à présent introduire le test d’arrêt. Une contrainte est qu’on voudra, à la fin de la
        boucle, savoir si oui ou non on s’est arrêté prématurément et, si c’est le cas, à quel indice.
      </paragraph>
      <paragraph>
        Il existe essentiellement deux solutions, avec ou sans variable booléenne. En général, la
        solution [A] sera plus claire si le test est court.
		  </paragraph>
		  
		  <paragraph title="Parcours avec sortie prématurée sans variable booléenne">
		  </paragraph>
		  <paragraph  cssClass="code">
// Parcours partiel d’un tableau sans variable booléenne
i ← 0
tant que i ≤ n-1 ET <formatted style="italic">test sur tab[i] dit qu'on continue</formatted> faire
    i ← i+1
fin tant que

si i ≥ n alors
    // on est arrivé au bout
sinon
    // arrêt prématuré à l’indice i.
fin si
      </paragraph>
      <paragraph>
        Il faut être attentif à <formatted style="bold">ne pas inverser les deux parties du test</formatted>. 
        Il faut absolument vérifier  que l’indice est bon avant de tester la valeur à cet indice.
      </paragraph>
      <paragraph>
        On pourrait inverser les deux branches du si-sinon en inversant le test mais attention à ne
        pas tester <formatted style="code">tab[i]</formatted> car <formatted style="code">i</formatted> n’est peut-être pas valide.
      </paragraph>
      <paragraph>
        Dans certains cas, le si-sinon peut se simplifier en un simple return d’une condition.
      </paragraph>
      <paragraph>Par exemple : </paragraph>
      <paragraph  cssClass="code">
// Indique si un zéro est présent dans le tableau
algorithme contientZéro(tab : tableau [1 à n] d’entiers) → booléen
    i : entier
    i ← 0
    tant que i ≤ n-1 ET tab[i] ≠ 0 faire
      i ← i+1
    fin tant que
    retourner i ≤ n-1 // Si le test est vrai c’est qu’on a trouvé un 0
fin algorithme
      </paragraph>
      
      <paragraph title="Parcours avec sortie prématurée avec variable booléenne">
		  </paragraph>
		  <paragraph  cssClass="code">
// Parcours partiel d’un tableau avec variable booléenne
i ← 0
trouvé ← faux
tant que i ≤ n-1 ET NON trouvé faire
    si <formatted style="italic">test sur tab[i] dit qu'on a trouvé</formatted> alors
      trouvé ← vrai
    sinon
      i ← i+1
    fin si
fin tant que
// tester le booléen pour savoir si arrêt prématuré.
      </paragraph>
      <paragraph>
        Attention à bien choisir un nom de booléen adapté au problème et à l’initialiser à la bonne
        valeur. Par exemple, si la variable s’appelle « continue »
        <list listStyle="ordered">
          <item>initialiser la variable à vrai ;</item>
          <item>le test de la boucle est « . . .ET continue » ;</item>
          <item>mettre la variable à faux pour sortir de la boucle.</item>
        </list>
      </paragraph>
    </clarify>
    
  </learningObject>


		<learningObject title="Erreurs fréquentes et exceptions lancées en Java">
		<!-- =========================================================== -->
		<clarify>
		  <paragraph>
		  <list listStyle="ordered">
          <item><formatted style="code">NullPointerException</formatted> : 
            si vous essayez d’accéder à un élément d’un tableau qui n’a pas été créé
            (le tableau vaut null dans ce cas) ;
          </item>
          <item><formatted style="code">ArrayIndexOutOfBoundsException</formatted> : 
            si vous donnez un indice qui n’existe pas (ex : tab [10] quand il n’y a que 10 éléments dans le tableau).
          </item>
        </list>
      </paragraph>
    </clarify>
    </learningObject>
    
	</unit>
		
  
  
	<!-- =========================================================== -->
	<unit label="Junit" title="Les tests">
	<!-- =========================================================== -->
    <learningObject title="Tests unitaires">
      <clarify>
        <paragraph title="Les tests unitaires">
          Tous les programmes réels contiennent des bugs (erreurs, défauts), parfois même beaucoup.
          C'est inacceptable :
          <list style="unordered"> 
            <item>Inconfort pour l’utilisateur</item>
            <item>Perte de temps, d’argent, de données, de matériel</item>
            <item>Voire danger pour la vie humaine, par exemple : <link uri="http://fr.wikipedia.org/wiki/Vol_501_d%27Ariane_5">l'échec du vol d'Ariane 5</link>.</item>
          </list>
        </paragraph>
        <paragraph>
          On peut trouver différents types d’erreurs : 
          <list style="unordered"> 
            <item>à la compilation</item>
            <item>à l’exécution, le programme s’arrête</item>
            <item>à l’exécution, le programme fournit une mauvaise réponse</item>
          </list>
          On pourrait aussi parler d’autres défauts
          <list style="unordered"> 
            <item>Trop lent</item>
            <item>Trop gourmand en mémoire</item>
          </list>
        </paragraph>
        <paragraph>
        Pour produire un logiciel sans bug il faut
         <list style="unordered"> 
            <item>
              suivre une méthodologie éprouvée pour produire une première version avec peu de bugs
              (cf. Analyse)
            </item>
            <item>
              tester, tester et . . . tester encore ! Pour détecter ceux qui restent
              <list style="unordered"> 
                <item>Besoin d’outils pour nous aider de façon à tester de la manière la plus facile/rapide possible</item>
                <item>Il existe plusieurs sortes de tests : unitaires, d’intégration, fonctionnels, non-régression, . . .</item>
                <item>Nous nous intéressons aux <link uri="http://fr.wikipedia.org/wiki/Test_(informatique)">tests unitaires</link> : 
                c'est une procédure permettant de tester le bon fonctionnement d’un algorithme (une méthode), ce qui n'est pas forcément suffisant.</item>
              </list>
            </item>
          </list>
        </paragraph>
        <paragraph title="Le plan de tests">
          Il faut planifier les tests, c'est-à-dire se demander quoi tester en choisissant les cas intéressants / judicieux.
          Pour ça, il faut se baser sur les erreurs fréquentes et cela viendra avec l'expérience.
        </paragraph>
        <paragraph>
          Nous avons besoin d’un plan reprenant les tests à effectuer
          <list style="unordered"> 
            <item>Quelles valeurs de paramètres sont pertinentes ?</item>
            <item>Quel est le résultat attendu ?</item>
          </list>
          Ce plan de tests doit être préparé pendant que l’on code 
          (ou même avant et éventuellement par une autre personne).
        </paragraph>
        <paragraph>
          Il permet de s’assurer que l’on teste tous les cas pertinents.
        </paragraph>
        <paragraph>
          On ne peut pas tester toutes les valeurs possibles
          <list style="unordered"> 
            <item>Il faut choisir des valeurs représentatives
              <list style="unordered"> 
                <item>Cas général / particuliers</item>
                <item>Valeurs limites</item>
              </list>
            </item>
            <item>Il faut imaginer les cas qui pourraient mettre en évidence un défaut de la méthode : 
            on s’inspire des erreurs les plus fréquentes en programmation :
            <list style="unordered"> 
              <item>On commence/arrête trop tôt/tard une boucle</item>
              <item>On initialise mal une variable</item>
              <item>Dans un test, on se trompe entre <![CDATA[< et ≤]]></item>
              <item>Dans un test, on se trompe entre ET et OU</item>
              <item>...</item>
            </list>
            C’est un savoir-faire ⇒ Importance de l’expérience
            </item>
          </list>
        </paragraph>
        <paragraph>
          Par exemple : <formatted style="code">public static int max(int n1, int n2, int n3) ...</formatted>
          qui calcule la valeur maximale de trois nombres.
        </paragraph>
        <paragraph>
          Que tester en plus du cas général ?
          <list style="unordered"> 
            <item>Le maximum est la première/dernière valeur</item>
            <item>Présence de nombres négatifs</item>
          </list>
        </paragraph>
        <paragraph>
          Par exemple : plan de tests de la méthode <formatted style="code">max</formatted> : 
        </paragraph>
		    <paragraph  cssClass="code">
#   nombres     résultat     ce qui est testé
1   1, 3, 0          3        cas général
2   1, −3, −4        1        maximum au début
3   1, 3, 11        11        maximum à la fin
4   −1, −3, −4      −1        que des négatifs
        </paragraph>
        <paragraph>
          <list style="unordered"> 
            <item>Quand tester ? 
              <list style="unordered"> 
                <item>Le plus souvent possible</item>
                <item>Erreur plus facile à identifier/corriger</item>
                <item>Idéalement après chaque méthode écrite</item>
              </list>
            </item>
            <item>Que tester ? 
              <list style="unordered"> 
                <item>Tout</item>
                <item>Le nouveau code peut mettre en évidence un problème dans le code ancien (régression)</item>
              </list>
            </item>
            <item>Comment tester ? 
              <list style="unordered"> 
                <item>Pas à la main : intenable</item>
                <item>Besoin d’un outil automatisé : <formatted style="bold">JUnit</formatted></item>
              </list>
            </item>
          </list>
        </paragraph>
        <paragraph title="JUnit">
          JUnit : outil pour automatiser les tests unitaires :
          <list style="unordered"> 
            <item>Le programmeur fournit les tests,</item>
            <item>JUnit exécute tous les tests et</item>
            <item>établit un rapport détaillant les problèmes</item>
          </list>
        </paragraph>
        <paragraph>
          La classe de test contient une méthode de test par cas. Cette méthode
          <list style="unordered"> 
            <item>est autonome (ne reçoit rien, ne retourne rien)</item>
            <item>contient des affirmations</item>
            <item>fait appel à la méthode à tester</item>
            <item>compare le résultat attendu et le résultat obtenu</item>
          </list>
        </paragraph>
        <paragraph>
          <multimedia src="../image/junit.jpeg" type="jpeg" />
        </paragraph>
        <paragraph>Par exemple</paragraph>
		    <paragraph  cssClass="code">
@Test
public void max_cas1() {
    int n1 = 1, n2 = 3, n3 = 0;
    assertEquals ( 3, MaClasse.max(n1, n2, n3) );
}
</paragraph>
        <paragraph>
          <list style="unordered"> 
            <item>Reconnu comme un test unitaire grâce à l’annotation <formatted style="code">@Test</formatted></item>
            <item>Pas de <formatted style="code">static</formatted></item>
            <item><formatted style="code">assertEquals</formatted> vérifie que les 2 valeurs sont identiques</item>
            <item><formatted style="code">assertTrue ( val )</formatted>, <formatted style="code">assertFalse ( val )</formatted>, . . .</item>
          </list>
        </paragraph>
        <paragraph title="Lancer les tests"/>    
				<paragraph>
					Pour lancer le test, il suffit de compiler la classe de test puis de lancer la commande : 
					<formatted style="code">java org.junit.runner.JUnitCore package.MaClasseTest</formatted>.
				</paragraph>    
				<paragraph>
					Cette commande lance les tests 
					et affiche un message récapitulatif du nombre de tests
					et du décompte de ceux qui ont réussi ou échoué.
				</paragraph>    
				<paragraph>
					Si cela ne fonctionne pas directement sur linux1 
					c'est que la JVM ne trouve pas la classe
					<formatted style="code">org.junit.runner.JUnitCore</formatted> 
					qui se trouve dans le fichier 
					<formatted style="italic">jar</formatted> 
					<formatted style="code">/usr/share/java/junit4.jar</formatted>.
					Il faudra donc ajouter ce chemin 
					à votre <formatted style="code">CLASSPATH</formatted> 
					et relancer un <formatted style="italic">shell</formatted> 
					afin que la variable d'environnement soit relue.
				</paragraph>    
				<paragraph>
					Certains d'entre vous ne voudront pas 
					entrer cette longue commande lors de chaque 
					lancement de tests.    
					Rien ne les empêche de définir un 
					<formatted style="italic">alias</formatted> avec la commande :
				</paragraph>    
				<paragraph cssClass="code">
	alias javatest='java org.junit.runner.JUnitCore'
				</paragraph>    
				<paragraph>
					et ils n'auront plus alors qu'à exécuter la commande
					<formatted style="code">javatest package.MaClasseTest</formatted>
					pour lancer la classe de tests.
				</paragraph>
      </clarify>
    </learningObject>
  </unit>
	
	<!-- =================================================================== -->
	<unit label="Exercices" title="Exercices">
	<!-- =================================================================== -->
		
		<entry>
			<paragraph>
				Maintenant, mettons tout ça en pratique.
      </paragraph>
    </entry>
    

    <learningObject title="En Java...">
      <act>
				<selfCheck title="Bornes d'un tableau" shuffle="no">
					<fillInBlanks>
						<question></question>
				        <gapText>
							<list style="unordered">
								<item>
									La variable permettant de se déplacer dans un tableau s'appelle un <gap answers="">indice</gap>
								</item>
								<item>
									En Java, la première valeur d'un tableau à <formatted style="bold">n</formatted> éléments se trouve à la position            
									<gap answers="">0</gap> 
									et la dernière valeur se trouve à la position 
									<gap answers="n-1, n- 1, n - 1, n -1">n-1</gap>
								</item>
							</list>
						</gapText>
						<solution></solution>
					</fillInBlanks>
				</selfCheck>
        
				<paragraph title="Déclaration, création et initialisation d'un tableau " icon="icon_reading"/>
				<paragraph>
					Un tableau possède un type et une taille.
					Le type de ses éléments est soit l'un des types simples (int, double, char,..) ou une réference (String,...).
				</paragraph>
				<paragraph>
					La taille du tableau est le nombre (strictement positif ) de ses éléments.
					Elle ne fait pas partie du type.  
				</paragraph>
          
				<selfCheck shuffle="yes">
					<multipleChoice>
						<question>La déclaration d'un tableau réserve un emplacement mémoire</question>
						<answer feedback="" correct="no">sur le tas.</answer>
						<answer feedback="" correct="yes">sur la pile.</answer>
					</multipleChoice>
				</selfCheck>
            
				<selfCheck title="Création" shuffle="no">
					<fillInBlanks>
						<question></question>
						<gapText>
							<paragraph>
								Pour créer un tableau, le mot clé utilisé est <gap answers="">new</gap> 
							</paragraph>
							<paragraph>
								Pour pouvoir créer un tableau nommé <formatted style="bold">entiers</formatted> 
								de 10 entiers <formatted style="bold">précédemment déclaré</formatted>, il faut écrire l'instruction
								<gap answers="">entiers</gap> <gap answers="">=</gap> <gap answers="">new</gap> <gap answers="">int</gap> <gap answers="[10], [ 10 ]">[10]</gap>;
							</paragraph>
						</gapText>
						<solution>
							La création permet de réserver l'espace mémoire sur le tas (heap). 
							Pour cela il faut spécifier la taille souhaitée.
						</solution>
					</fillInBlanks>
				</selfCheck>
            
				<selfCheck shuffle="yes">
					<multipleChoice>
						<question>La création d'un tableau se fait</question>
						<answer feedback="" correct="yes">sur le tas</answer>
						<answer feedback="" correct="no">sur la pile</answer>
					</multipleChoice>
				</selfCheck>
            
				<selfCheck title="Initialisation" shuffle="no">
					
					<fillInBlanks>
						<question>
							<paragraph>
								Le mot clé <formatted style="java">new</formatted> permet également d'initialiser
								tous les éléments du tableau fraichement créé à une valeur par défaut. 
							</paragraph>
							<paragraph>Quelle est cette valeur par défaut ?</paragraph>
						</question>
						<gapText> 
							<list style="unordered">
								<item>pour les numériques (int, double, char) : <gap answers="zéro,0">0</gap></item>
								<item>pour les boolean : <gap answers="">false</gap></item>
								<item>pour les objets (type réference) : <gap answers="">null</gap></item>
							</list>						
						</gapText>
						<solution/>
					</fillInBlanks>
				</selfCheck>
            
				<paragraph title="Réflexion" icon="question"/>  
				<paragraph>  
					Est-il possible de déclarer, de créer et d'initialiser un tableau de 10 éléments en une seule opération ?  
				</paragraph>  
				<popup title="la réponse">  
					<paragraph>  
						Oui, on peut condenser l'écriture :
					</paragraph>  
					<paragraph cssClass="java">  
int [] entiers = new int[10];  
					</paragraph>  
					<paragraph>
						et pour une initialisation personnalisée:
					</paragraph>
					<paragraph cssClass="java">  
int [] entiers = {0,4,5,6,6,7,2,1,8,9};
					</paragraph>
				</popup>

				<paragraph title="Vérification" icon="icon_activity"/>
				<paragraph>
					Écrivez sur papier la boucle permettant d'initialiser
					les éléments d'un tableau d'entiers de 10 éléments à la valeur de leur indice.   
				</paragraph>
				<popup title="la réponse">   
					<paragraph cssClass="java">
    for(int i=0; i&lt;10; i++) {
        entiers[i] = i ;
    }  
					</paragraph>
				</popup> 

				<selfCheck title="Cochez les affirmations qui sont vraies" shuffle="yes">
					<multipleChoice>
						<question>
							Considerons le tableau <formatted style="java">entiers</formatted>
							contenant les élements <formatted style="java">{3,4,5}</formatted>.
						</question>
						<answer feedback="Un tableau connait sa taille via son attribut length" correct="yes">
							Le tableau connait sa taille.
						</answer>
						<answer feedback="Il n'est pas possible d'utiliser des indices se trouvant en dehors des bornes du tableau." correct="no">
							<formatted style="java">entiers[3]</formatted> vaut 5.
						</answer>
						<answer feedback="Il n'est pas possible d'utiliser des indices se trouvant en dehors des bornes du tableau." correct="no">
							<formatted style="java">entiers[3]=4;</formatted> affecte la valeur 4 à la 3<formatted style="superscript">ème</formatted> case.
						</answer>
						<answer feedback="Mettre une case à 0 ne la supprime pas" correct="no">
							<formatted style="java">entiers[1]=0;</formatted> supprime la case d'indice 1.
						</answer>
						<answer feedback="La taille n'a pas d'importance ici car on manipule la réference du tableau et non pas ses valeurs." correct="yes">
							Si <formatted style="java">entiers20</formatted> est un tableau de 20 entiers, on peut écrire l'instruction 
							<formatted style="java">entiers20 = entiers;</formatted>.  
						</answer>
						<answer feedback="Étant donné qu'un tableau connait sa taille via son attribut length, on ne doit plus la fournir comme second paramètre à la méthode." correct="yes">
							Un tableau peut être le seul paramètre d'une méthode.
						</answer>
						<answer feedback="C'est plutôt un grand avantage de pouvoir retourner plusieurs valeurs non ? En fait on ne retourne qu'une  réference vers toutes ces valeurs." correct="yes">
							Un tableau peut être une valeur de retour d'une méthode.
						</answer>
					</multipleChoice>
				</selfCheck>
          
				<selfCheck title="Sélection multiple" shuffle="no">
					<multipleChoice>
						<question> 
							<paragraph>
								Partons de la représentation de <formatted style="java">entiers </formatted>en mémoire
								donnée par la figure ci-dessous.  
							<multimedia src="../image/tab3.jpg" type="jpeg" legend="représentation mémoire de entiers"
							width="50" units="percent"/>
							</paragraph>
							<paragraph>
								Quelle(s) instruction(s) mène(nt) à ce résultat.   
							</paragraph>
						</question>
						<answer feedback="" correct="no">
							<paragraph>proposition 1</paragraph>
							<paragraph cssClass="java">
int [] entiers;
entiers = new int [3];
							</paragraph>
						</answer>
						
						<answer feedback="" correct="no">
							<paragraph>proposition 2</paragraph>
							<paragraph cssClass="java">
int [] entiers = new int [3]; 
							</paragraph>
						</answer>
						
						<answer feedback="" correct="no">
							<paragraph>proposition 3</paragraph>
							<paragraph cssClass="java">
int [] entiers = new int [];
							</paragraph>
						</answer>
						
						<answer feedback="" correct="yes">
							<paragraph>proposition 4</paragraph>
							<paragraph cssClass="java">
int [] entiers = {3,3,3};
							</paragraph>
						</answer>
						
						<answer feedback="" correct="yes">
							<paragraph>proposition 5</paragraph>
							<paragraph cssClass="java">
int [] entiers = new int [3];
for (int i=0; i&lt;entiers.length; i++) {
	entiers[i] = 3;
}
							</paragraph>
						</answer>
						
						<answer feedback="" correct="no">
							<paragraph>proposition 6</paragraph>
							<paragraph cssClass="java">
int[] entiers;
entiers = {3,3,3};
							</paragraph>
						</answer>
						
						<answer feedback="" correct="no">
							<paragraph>proposition 7</paragraph>
							<paragraph cssClass="java">
int [3] entiers = {3,3,3};
							</paragraph>
						</answer>
						
						<answer feedback="" correct="no">
							<paragraph>proposition 8</paragraph>
							<paragraph cssClass="java">
int [] entiers;
entiers= new {3,3,3};
							</paragraph>
						</answer>
					</multipleChoice>
				</selfCheck>
        
				<selfCheck title="Quiz" shuffle="yes">
					<multipleChoice>
						<question>Pour ce tableau de 3 éléments, l'instruction <formatted style="java">System.out.println (entiers[6]);</formatted></question>
						<answer feedback="" correct="no">n'affiche rien.</answer>
						<answer feedback="" correct="no">affiche une valeur se trouvant en mémoire.</answer>
						<answer feedback="" correct="no">provoque une erreur à la compilation.</answer>
						<answer feedback="" correct="yes">provoque une  erreur à l'exécution.</answer>
					</multipleChoice>
				</selfCheck>
				
    </act>
		</learningObject>
		
    <learningObject title="Les tests unitaires">
      <act>
				<selfCheck title="Les tests" shuffle="no">
					<fillInBlanks>
						<question></question>
						<gapText>  
							<paragraph>    
								Le type de tests qui  teste séparément chaque méthode est appelé tests <gap answers="">unitaires</gap>.
							</paragraph>    
							<paragraph>    
								Avant de commencer à tester, il faut écrire un <gap answers="">plan</gap> de tests afin de s'assurer qu'on teste tous les cas.
							</paragraph>    
							<paragraph>    
								Bien sûr, il n'est pas pensable de tester toutes les valeurs possibles, il faut donc choisir des valeurs représentatives 
								(c-à-d cas général, cas particuliers et valeurs limites).    
							</paragraph>    
							<paragraph><gap answers="">JUnit</gap> est un outil pour automatiser les tests unitaires.
							</paragraph>
							<paragraph>    
								Cette méthode est autonome (ne reçoit rien ne retourne rien) 
								et elle ne contient que des affirmations 
								(appel de la méthode à tester, comparaison entre le résultat attendu et le résultat obtenu).
							</paragraph>    
							<paragraph>    
								Une classe de test contient une méthode de test par cas.
								Chaque méthode de test est reconnue comme étant un test unitaire grâce au tag <formatted style="javawithblanks"><gap answers="">@Test</gap></formatted>.
								Elle contient des affirmations :
							</paragraph>    
							<list style="unordered"> 
								<item>
								<formatted style="javawithblanks"><gap answers="">assertEquals</gap>(intAttendu, intObtenu)</formatted> 
								<paragraph>
								  vérifie que les 2 valeurs entières <formatted style="java">intAttendu</formatted> et <formatted style="java">intObtenus</formatted> sont identiques;
								</paragraph>
								</item>								
								<item>
								<formatted style="javawithblanks"><gap answers="">assertTrue</gap>(val)</formatted> 
								<paragraph>
								  vérifie que la valeur du booléen <formatted style="java">val</formatted> est à vrai,     
                </paragraph>
								</item>								
								<item>
								<formatted style="javawithblanks"><gap answers="">assertFalse</gap>(val)</formatted> 
								<paragraph>
								  vérifie que la valeur de <formatted style="java">val</formatted> est à faux.    
                </paragraph>
								</item>								
							</list>    
							<paragraph>    
								Le tag <formatted style="javawithblanks"><gap answers="">@Test</gap> (<gap answers="">expected=IllegalArgumentException.class</gap>)</formatted> 
                permet de vérifier que la méthode lance bien une exception de type <formatted style="java">IllegalArgumentException</formatted>.    
							</paragraph>
							<paragraph>
                Dans la classe de tests, 2 instructions <formatted style="java">import</formatted> sont nécessaires :    
							<list style="unordered"> 
							<item>
								<formatted style="javawithblanks">import <gap answers="">org</gap>.<gap answers="">junit</gap>.<gap answers="">Test</gap>;</formatted>
                // Pour que @Test soit connu
                </item>
                <item>
                <formatted style="javawithblanks">import <gap answers="">static</gap> 
                <gap answers="">org</gap>.<gap answers="">junit</gap>.<gap answers="">Assert</gap>.<gap answers="">*</gap>;</formatted>
                // Pour que les méthodes de vérification ci-dessus soient reconnues.
                </item>
                </list>
							</paragraph>
							<paragraph>    
								La commande
								<newLine/>
								<formatted style="javawithblanks">
								<gap answers="">java</gap> 
								<gap answers="">org.junit.runner.JUnitCore</gap>
								<gap answers="">g32000.tds.tdTableaux.ExerciceTest</gap></formatted><newLine/>
								permet de lancer les tests de la classe <formatted style="java">ExerciceTest</formatted>, 
								dont le package est <formatted style="java">g32000.tds.tdTableaux</formatted>, précédemment compilée.    
							</paragraph>    
						</gapText>
						<solution/>
					</fillInBlanks>
				</selfCheck>
			</act>
			</learningObject>
    
    <learningObject title="À vous de jouer...">
    <!-- ============================================================ -->
      <act>
        <paragraph>
          N'oubliez pas nos quelques conseils pour vous guider dans la résolution de tels problèmes :
          <list listStyle="unordered">
            <item>il convient d’abord de bien comprendre le problème posé ; assurez-vous qu’il est parfaitement spécifié ;</item>
            <item>résolvez le problème via quelques exemples précis ;</item>
            <item>mettez en évidence les variables <formatted style="bold">« données »</formatted>, les variables <formatted style="bold">« résultats »</formatted> et les variables de travail ;</item>
            <item>n’hésitez pas à faire une ébauche de résolution en français avant d’élaborer l’algorithme définitif pseudo-codé ;</item>
            <item>déclarez ensuite les variables (et leur type) qui interviennent dans chaque algorithme ; les noms des variables risquant de ne pas être suffisamment explicites.</item>
            <item>Écrivez la partie algorithmique <formatted style="bold">AVANT</formatted> de vous lancer dans la programmation en Java.</item>
            <item>Demandez-vous si vous avez besoin de parcourir tout le tableau ou de sortir prématurément (si on a trouvé ce qu'on cherche par exemple).</item>
            <item>Pour la partie Java, dessinez l'arborescence des fichiers. </item>
            <item><formatted style="bold">Écrivez le plan de tests en écrivant l'algorithme. Codez les tests après avoir écrit le code Java.</formatted></item>
          </list>
        </paragraph>
           
        <paragraph>
        Écrivez les algorithmes et codez les programmes Java correspondant qui 
          <list listStyle="ordered">
            <item> reçoit en paramètre le tableau <formatted style="code">températures</formatted> de 
              <formatted style="code">n</formatted>  réels et qui retourne
              le plus grand écart absolu entre deux températures consécutives de ce tableau. Et si on veut
              le plus petit écart ?
            </item>
            <item>
              reçoit en paramètre le tableau valeurs de <formatted style="code">n</formatted> entiers et qui vérifie si ce
              tableau est ordonné (strictement) croissant sur les valeurs. L'algorithme retournera vrai si le
              tableau est ordonné, faux sinon.
            </item>
            <item>
              reçoit en paramètre le tableau <formatted style="code">tabCar</formatted> 
              de <formatted style="code">n</formatted> caractères, et qui « renverse »
              ce tableau, c’est-à-dire qui permute le premier élément avec le dernier, le deuxième élément
              avec l’avant-dernier et ainsi de suite.
              </item>
            <item>
              reçoit en paramètre le tableau <formatted style="code">tabChaines</formatted> 
              de <formatted style="code">n</formatted> chaines et qui vérifie
              si ce tableau est symétrique, c’est-à-dire si le premier élément est identique au dernier, le
              deuxième à l’avant-dernier et ainsi de suite.
            </item>
            <item>
              reçoit un nombre entier positif ou nul en paramètre et qui affiche pour
              chacun de ses chiffres le nombre de fois qu’il apparait dans ce nombre. Ainsi, pour le nombre
              10502851125, l’affichage mentionnera que le chiffre 0 apparait 2 fois, 1 apparait 3 fois, 2
              apparait 2 fois, 5 apparait 3 fois et 8 apparait une fois (l’affichage ne mentionnera donc pas
              les chiffres qui n’apparaissent pas).
            </item>
            <item>
              vérifie si un tableau d' entiers donné forme un palindrome ou non. Un nombre
              palindrome est un nombre qui lu dans un sens (de gauche à droite) est identique au nombre
              lu dans l’autre sens (de droite à gauche). Par exemple, 1047401 est un nombre palindrome.
            </item>
          </list>
        </paragraph>
        <paragraph>En java, n'oubliez pas d'écrire la javadoc et les tests de vos méthodes.</paragraph>
        
        <paragraph title="Mastermind">
          Dans le jeu du Mastermind, un joueur A doit trouver une combinaison de 
          <formatted style="code">k</formatted> pions de couleur,
          choisie et tenue secrète par un autre joueur B. Cette combinaison peut contenir éventuellement 
          des pions de même couleur. À chaque proposition du joueur A, le joueur B indique
          le nombre de pions de la proposition qui sont corrects et bien placés et le nombre de pions
          corrects mais mal placés.
        </paragraph>
        <paragraph>
          Pour implémenter une simulation de ce jeu, on utilise le type Chaine, dont les valeurs
          possibles sont les couleurs des pions utilisés. (Attention, le nombre exact de couleurs n’est
          pas précisé.) Les seules manipulations permises ont la comparaison (tester si
          deux couleurs sont identiques ou non) et l’affectation (affecter le contenu d’une variable de
          type Couleur à une autre variable de ce type). Les propositions du joueur A, ainsi que la
          combinaison secrète du joueur B sont contenues dans des tableaux de k composantes de type
          Chaine.
        </paragraph>
        <paragraph>
          Écrire l'algorithme suivant qui renvoie dans les variables <formatted style="code">bienPlacés</formatted> 
          et <formatted style="code">malPlacés</formatted> respectivement
          le nombre de pions bien placés et mal placés dans la « proposition » du joueur A en la
          comparant à la « solution » cachée du joueur B.
        </paragraph>
        <paragraph  cssClass="code">
algorithme testerProposition( proposition↓, solution↓ : tableau de k chaines, bienPlacés↑, malPlacés↑ : entiers)
        </paragraph>
        <popup title="une solution">
          <paragraph>
            En cas de besoin, vous trouverez une solution <link uri="../../../TDTableau/fr/solution/CorrectionMastermind.pdf">ici</link>.
          </paragraph>
        </popup>
        <paragraph>En java, n'oubliez pas d'écrire la javadoc et les tests de vos méthodes.</paragraph>
      </act>
    </learningObject>
  </unit>
</lesson>
